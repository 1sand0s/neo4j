/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.cypher

import org.neo4j.configuration.GraphDatabaseSettings.DEFAULT_DATABASE_NAME
import org.neo4j.configuration.GraphDatabaseSettings.SYSTEM_DATABASE_NAME
import org.neo4j.configuration.GraphDatabaseSettings.auth_enabled
import org.neo4j.cypher.internal.RewindableExecutionResult
import org.neo4j.cypher.internal.expressions.functions.Category.AGGREGATING
import org.neo4j.cypher.internal.expressions.functions.Category.LIST
import org.neo4j.cypher.internal.expressions.functions.Category.LOGARITHMIC
import org.neo4j.cypher.internal.expressions.functions.Category.NUMERIC
import org.neo4j.cypher.internal.expressions.functions.Category.PREDICATE
import org.neo4j.cypher.internal.expressions.functions.Category.SCALAR
import org.neo4j.cypher.internal.expressions.functions.Category.SPATIAL
import org.neo4j.cypher.internal.expressions.functions.Category.STRING
import org.neo4j.cypher.internal.expressions.functions.Category.TEMPORAL
import org.neo4j.cypher.internal.expressions.functions.Category.TRIGONOMETRIC
import org.neo4j.graphdb.config.Setting
import org.neo4j.internal.kernel.api.connectioninfo.ClientConnectionInfo
import org.neo4j.kernel.api.KernelTransaction.Type
import org.neo4j.kernel.api.procedure.GlobalProcedures
import org.neo4j.kernel.api.security.AuthManager
import org.neo4j.kernel.internal.GraphDatabaseAPI
import org.neo4j.procedure.Description
import org.neo4j.procedure.Mode.DBMS
import org.neo4j.procedure.Mode.READ
import org.neo4j.procedure.Mode.SCHEMA
import org.neo4j.procedure.Mode.WRITE
import org.neo4j.procedure.Name
import org.neo4j.procedure.UserAggregationFunction
import org.neo4j.procedure.UserAggregationResult
import org.neo4j.procedure.UserAggregationUpdate
import org.neo4j.procedure.UserFunction
import org.neo4j.server.security.auth.SecurityTestUtils
import org.neo4j.values.AnyValue
import org.neo4j.values.storable.Values
import org.neo4j.values.virtual.ListValue
import org.neo4j.values.virtual.VirtualValues

import scala.collection.JavaConverters.seqAsJavaListConverter

class CommunityShowFuncProcAcceptanceTest extends ExecutionEngineFunSuite with GraphDatabaseTestSupport {
  private val username = "foo"
  private val password = "secret"

  override def databaseConfig(): Map[Setting[_], Object] = super.databaseConfig() ++ Map(auth_enabled -> java.lang.Boolean.TRUE)

  override protected def onNewGraphDatabase(): Unit = {
    super.onNewGraphDatabase()
    val globalProcedures: GlobalProcedures = graphOps.asInstanceOf[GraphDatabaseAPI].getDependencyResolver.resolveDependency(classOf[GlobalProcedures])
    globalProcedures.registerFunction(classOf[TestShowFunction])
    globalProcedures.registerAggregationFunction(classOf[TestShowFunction])
  }

  // SHOW FUNCTIONS

  private val builtInFunctionsBrief = List(
    Map("name" -> "abs", "category" -> NUMERIC, "description" -> "Returns the absolute value of an integer."),
    Map("name" -> "abs", "category" -> NUMERIC, "description" -> "Returns the absolute value of a floating point number."),
    Map("name" -> "acos", "category" -> TRIGONOMETRIC, "description" -> "Returns the arccosine of a number in radians."),
    Map("name" -> "all", "category" -> PREDICATE, "description" -> "Returns true if the predicate holds for all elements in the given list."),
    Map("name" -> "any", "category" -> PREDICATE, "description" -> "Returns true if the predicate holds for at least one element in the given list."),
    Map("name" -> "asin", "category" -> TRIGONOMETRIC, "description" -> "Returns the arcsine of a number in radians."),
    Map("name" -> "atan", "category" -> TRIGONOMETRIC, "description" -> "Returns the arctangent of a number in radians."),
    Map("name" -> "atan2", "category" -> TRIGONOMETRIC, "description" -> "Returns the arctangent2 of a set of coordinates in radians."),
    Map("name" -> "avg", "category" -> AGGREGATING, "description" -> "Returns the average of a set of integer values."),
    Map("name" -> "avg", "category" -> AGGREGATING, "description" -> "Returns the average of a set of floating point values."),
    Map("name" -> "avg", "category" -> AGGREGATING, "description" -> "Returns the average of a set of duration values."),
    Map("name" -> "ceil", "category" -> NUMERIC, "description" -> "Returns the smallest floating point number that is greater than or equal to a number and equal to a mathematical integer."),
    Map("name" -> "coalesce", "category" -> SCALAR, "description" -> "Returns the first non-null value in a list of expressions."),
    Map("name" -> "collect", "category" -> AGGREGATING, "description" -> "Returns a list containing the values returned by an expression."),
    Map("name" -> "cos", "category" -> TRIGONOMETRIC, "description" -> "Returns the cosine  of a number."),
    Map("name" -> "cot", "category" -> TRIGONOMETRIC, "description" -> "Returns the cotangent of a number."),
    Map("name" -> "count", "category" -> AGGREGATING, "description" -> "Returns the number of values or rows."),
    Map("name" -> "date", "category" -> TEMPORAL, "description" -> "Create a Date instant."),
    Map("name" -> "date.realtime", "category" -> TEMPORAL, "description" -> "Get the current Date instant using the realtime clock."),
    Map("name" -> "date.statement", "category" -> TEMPORAL, "description" -> "Get the current Date instant using the statement clock."),
    Map("name" -> "date.transaction", "category" -> TEMPORAL, "description" -> "Get the current Date instant using the transaction clock."),
    Map("name" -> "date.truncate", "category" -> TEMPORAL, "description" -> "Truncate the input temporal value to a Date instant using the specified unit."),
    Map("name" -> "datetime", "category" -> TEMPORAL, "description" -> "Create a DateTime instant."),
    Map("name" -> "datetime.fromepoch", "category" -> TEMPORAL, "description" -> "Create a DateTime given the seconds and nanoseconds since the start of the epoch."),
    Map("name" -> "datetime.fromepochmillis", "category" -> TEMPORAL, "description" -> "Create a DateTime given the milliseconds since the start of the epoch."),
    Map("name" -> "datetime.realtime", "category" -> TEMPORAL, "description" -> "Get the current DateTime instant using the realtime clock."),
    Map("name" -> "datetime.statement", "category" -> TEMPORAL, "description" -> "Get the current DateTime instant using the statement clock."),
    Map("name" -> "datetime.transaction", "category" -> TEMPORAL, "description" -> "Get the current DateTime instant using the transaction clock."),
    Map("name" -> "datetime.truncate", "category" -> TEMPORAL, "description" -> "Truncate the input temporal value to a DateTime instant using the specified unit."),
    Map("name" -> "degrees", "category" -> TRIGONOMETRIC, "description" -> "Converts radians to degrees."),
    Map("name" -> "distance", "category" -> SPATIAL, "description" -> "Returns a floating point number representing the geodesic distance between any two points in the same CRS."),
    Map("name" -> "duration", "category" -> TEMPORAL, "description" -> "Construct a Duration value."),
    Map("name" -> "duration.between", "category" -> TEMPORAL, "description" -> "Compute the duration between the 'from' instant (inclusive) and the 'to' instant (exclusive) in logical units."),
    Map("name" -> "duration.inDays", "category" -> TEMPORAL, "description" -> "Compute the duration between the 'from' instant (inclusive) and the 'to' instant (exclusive) in days."),
    Map("name" -> "duration.inMonths", "category" -> TEMPORAL, "description" -> "Compute the duration between the 'from' instant (inclusive) and the 'to' instant (exclusive) in months."),
    Map("name" -> "duration.inSeconds", "category" -> TEMPORAL, "description" -> "Compute the duration between the 'from' instant (inclusive) and the 'to' instant (exclusive) in seconds."),
    Map("name" -> "e", "category" -> LOGARITHMIC, "description" -> "Returns the base of the natural logarithm, e."),
    Map("name" -> "endNode", "category" -> SCALAR, "description" -> "Returns the end node of a relationship."),
    Map("name" -> "exists", "category" -> PREDICATE, "description" -> "Returns true if a match for the pattern exists in the graph, or if the specified property exists in the node, relationship or map."),
    Map("name" -> "exp", "category" -> LOGARITHMIC, "description" -> "Returns e^n, where e is the base of the natural logarithm, and n is the value of the argument expression."),
    Map("name" -> "file", "category" -> SCALAR, "description" -> "Returns the absolute path of the file that LOAD CSV is using."),
    Map("name" -> "floor", "category" -> NUMERIC, "description" -> "Returns the largest floating point number that is less than or equal to a number and equal to a mathematical integer."),
    Map("name" -> "haversin", "category" -> TRIGONOMETRIC, "description" -> "Returns half the versine of a number."),
    Map("name" -> "head", "category" -> SCALAR, "description" -> "Returns the first element in a list."),
    Map("name" -> "id", "category" -> SCALAR, "description" -> "Returns the id of a node."),
    Map("name" -> "id", "category" -> SCALAR, "description" -> "Returns the id of a relationship."),
    Map("name" -> "isEmpty", "category" -> PREDICATE, "description" -> "Checks whether a list is empty."),
    Map("name" -> "isEmpty", "category" -> PREDICATE, "description" -> "Checks whether a map is empty."),
    Map("name" -> "isEmpty", "category" -> PREDICATE, "description" -> "Checks whether a string is empty."),
    Map("name" -> "keys", "category" -> LIST, "description" -> "Returns a list containing the string representations for all the property names of a node."),
    Map("name" -> "keys", "category" -> LIST, "description" -> "Returns a list containing the string representations for all the property names of a relationship"),
    Map("name" -> "keys", "category" -> LIST, "description" -> "Returns a list containing the string representations for all the property names of a map."),
    Map("name" -> "labels", "category" -> LIST, "description" -> "Returns a list containing the string representations for all the labels of a node."),
    Map("name" -> "last", "category" -> SCALAR, "description" -> "Returns the last element in a list."),
    Map("name" -> "left", "category" -> STRING, "description" -> "Returns a string containing the specified number of leftmost characters of the original string."),
    Map("name" -> "length", "category" -> SCALAR, "description" -> "Returns the length of a path."),
    Map("name" -> "linenumber", "category" -> SCALAR, "description" -> "Returns the line number that LOAD CSV is currently using."),
    Map("name" -> "localdatetime", "category" -> TEMPORAL, "description" -> "Create a LocalDateTime instant."),
    Map("name" -> "localdatetime.realtime", "category" -> TEMPORAL, "description" -> "Get the current LocalDateTime instant using the realtime clock."),
    Map("name" -> "localdatetime.statement", "category" -> TEMPORAL, "description" -> "Get the current LocalDateTime instant using the statement clock."),
    Map("name" -> "localdatetime.transaction", "category" -> TEMPORAL, "description" -> "Get the current LocalDateTime instant using the transaction clock."),
    Map("name" -> "localdatetime.truncate", "category" -> TEMPORAL, "description" -> "Truncate the input temporal value to a LocalDateTime instant using the specified unit."),
    Map("name" -> "localtime", "category" -> TEMPORAL, "description" -> "Create a LocalTime instant."),
    Map("name" -> "localtime.realtime", "category" -> TEMPORAL, "description" -> "Get the current LocalTime instant using the realtime clock."),
    Map("name" -> "localtime.statement", "category" -> TEMPORAL, "description" -> "Get the current LocalTime instant using the statement clock."),
    Map("name" -> "localtime.transaction", "category" -> TEMPORAL, "description" -> "Get the current LocalTime instant using the transaction clock."),
    Map("name" -> "localtime.truncate", "category" -> TEMPORAL, "description" -> "Truncate the input temporal value to a LocalTime instant using the specified unit."),
    Map("name" -> "log", "category" -> LOGARITHMIC, "description" -> "Returns the natural logarithm of a number."),
    Map("name" -> "log10", "category" -> LOGARITHMIC, "description" -> "Returns the common logarithm (base 10) of a number."),
    Map("name" -> "ltrim", "category" -> STRING, "description" -> "Returns the original string with leading whitespace removed."),
    Map("name" -> "max", "category" -> AGGREGATING, "description" -> "Returns the maximum value in a set of values."),
    Map("name" -> "min", "category" -> AGGREGATING, "description" -> "Returns the minimum value in a set of values."),
    Map("name" -> "nodes", "category" -> LIST, "description" -> "Returns a list containing all the nodes in a path."),
    Map("name" -> "none", "category" -> PREDICATE, "description" -> "Returns true if the predicate holds for no element in the given list."),
    Map("name" -> "percentileCont", "category" -> AGGREGATING, "description" -> "Returns the percentile of a value over a group using linear interpolation."),
    Map("name" -> "percentileDisc", "category" -> AGGREGATING, "description" -> "Returns the nearest integer value to the given percentile over a group using a rounding method."),
    Map("name" -> "percentileDisc", "category" -> AGGREGATING, "description" -> "Returns the nearest floating point value to the given percentile over a group using a rounding method."),
    Map("name" -> "pi", "category" -> TRIGONOMETRIC, "description" -> "Returns the mathematical constant pi."),
    Map("name" -> "point", "category" -> SPATIAL, "description" -> "Returns a 2D or 3D point object, given two or respectively three coordinate values in the Cartesian coordinate system or WGS 84 geographic coordinate system."),
    Map("name" -> "properties", "category" -> SCALAR, "description" -> "Returns a map containing all the properties of a node."),
    Map("name" -> "properties", "category" -> SCALAR, "description" -> "Returns a map containing all the properties of a relationship."),
    Map("name" -> "properties", "category" -> SCALAR, "description" -> "Returns a map containing all the properties of a map."),
    Map("name" -> "radians", "category" -> TRIGONOMETRIC, "description" -> "Converts degrees to radians."),
    Map("name" -> "rand", "category" -> NUMERIC, "description" -> "Returns a random floating point number in the range from 0 (inclusive) to 1 (exclusive); i.e. [0,1)."),
    Map("name" -> "randomUUID", "category" -> SCALAR, "description" -> "Generates a random UUID."),
    Map("name" -> "range", "category" -> LIST, "description" -> "Returns a list comprising all integer values within a specified range."),
    Map("name" -> "range", "category" -> LIST, "description" -> "Returns a list comprising all integer values within a specified range created with step length."),
    Map("name" -> "reduce", "category" -> LIST, "description" -> "Runs an expression against individual elements of a list, storing the result of the expression in an accumulator."),
    Map("name" -> "relationships", "category" -> LIST, "description" -> "Returns a list containing all the relationships in a path."),
    Map("name" -> "replace", "category" -> STRING, "description" -> "Returns a string in which all occurrences of a specified search string in the original string have been replaced by another (specified) replace string."),
    Map("name" -> "reverse", "category" -> STRING, "description" -> "Returns a string in which the order of all characters in the original string have been reversed."),
    Map("name" -> "reverse", "category" -> LIST, "description" -> "Returns a list in which the order of all elements in the original list have been reversed."),
    Map("name" -> "right", "category" -> STRING, "description" -> "Returns a string containing the specified number of rightmost characters of the original string."),
    Map("name" -> "round", "category" -> NUMERIC, "description" -> "Returns the value of a number rounded to the nearest integer."),
    Map("name" -> "round", "category" -> NUMERIC, "description" -> "Returns the value of a number rounded to the specified precision using rounding mode HALF_UP."),
    Map("name" -> "round", "category" -> NUMERIC, "description" -> "Returns the value of a number rounded to the specified precision with the specified rounding mode."),
    Map("name" -> "rtrim", "category" -> STRING, "description" -> "Returns the original string with trailing whitespace removed."),
    Map("name" -> "sign", "category" -> NUMERIC, "description" -> "Returns the signum of an integer number: 0 if the number is 0, -1 for any negative number, and 1 for any positive number."),
    Map("name" -> "sign", "category" -> NUMERIC, "description" -> "Returns the signum of a floating point number: 0 if the number is 0, -1 for any negative number, and 1 for any positive number."),
    Map("name" -> "sin", "category" -> TRIGONOMETRIC, "description" -> "Returns the sine of a number."),
    Map("name" -> "single", "category" -> PREDICATE, "description" -> "Returns true if the predicate holds for exactly one of the elements in the given list."),
    Map("name" -> "size", "category" -> SCALAR, "description" -> "Returns the number of items in a list."),
    Map("name" -> "size", "category" -> SCALAR, "description" -> "Returns the number of Unicode characters in a string."),
    Map("name" -> "split", "category" -> STRING, "description" -> "Returns a list of strings resulting from the splitting of the original string around matches of the given delimiter."),
    Map("name" -> "split", "category" -> STRING, "description" -> "Returns a list of strings resulting from the splitting of the original string around matches of any of the given delimiters."),
    Map("name" -> "sqrt", "category" -> LOGARITHMIC, "description" -> "Returns the square root of a number."),
    Map("name" -> "startNode", "category" -> SCALAR, "description" -> "Returns the start node of a relationship."),
    Map("name" -> "stdev", "category" -> AGGREGATING, "description" -> "Returns the standard deviation for the given value over a group for a sample of a population."),
    Map("name" -> "stdevp", "category" -> AGGREGATING, "description" -> "Returns the standard deviation for the given value over a group for an entire population."),
    Map("name" -> "substring", "category" -> STRING, "description" -> "Returns a substring of the original string, beginning with a 0-based index start."),
    Map("name" -> "substring", "category" -> STRING, "description" -> "Returns a substring of length 'length' of the original string, beginning with a 0-based index start."),
    Map("name" -> "sum", "category" -> AGGREGATING, "description" -> "Returns the sum of a set of integers"),
    Map("name" -> "sum", "category" -> AGGREGATING, "description" -> "Returns the sum of a set of floats"),
    Map("name" -> "sum", "category" -> AGGREGATING, "description" -> "Returns the sum of a set of durations"),
    Map("name" -> "tail", "category" -> LIST, "description" -> "Returns all but the first element in a list."),
    Map("name" -> "tan", "category" -> TRIGONOMETRIC, "description" -> "Returns the tangent of a number."),
    Map("name" -> "time", "category" -> TEMPORAL, "description" -> "Create a Time instant."),
    Map("name" -> "time.realtime", "category" -> TEMPORAL, "description" -> "Get the current Time instant using the realtime clock."),
    Map("name" -> "time.statement", "category" -> TEMPORAL, "description" -> "Get the current Time instant using the statement clock."),
    Map("name" -> "time.transaction", "category" -> TEMPORAL, "description" -> "Get the current Time instant using the transaction clock."),
    Map("name" -> "time.truncate", "category" -> TEMPORAL, "description" -> "Truncate the input temporal value to a Time instant using the specified unit."),
    Map("name" -> "toBoolean", "category" -> SCALAR, "description" -> "Converts a string value to a boolean value."),
    Map("name" -> "toBoolean", "category" -> SCALAR, "description" -> "Converts a boolean value to a boolean value."),
    Map("name" -> "toBoolean", "category" -> SCALAR, "description" -> "Converts a integer value to a boolean value. 0 is defined to be FALSE and any other integer is defined to be TRUE."),
    Map("name" -> "toBooleanList", "category" -> LIST, "description" -> "Converts a list of values to a list of boolean values. If any values are not convertible to boolean they will be null in the list returned."),
    Map("name" -> "toBooleanOrNull", "category" -> SCALAR, "description" -> "Converts a value to a boolean value, or null if the value cannot be converted."),
    Map("name" -> "toFloat", "category" -> SCALAR, "description" -> "Converts a string value to a floating point value."),
    Map("name" -> "toFloat", "category" -> SCALAR, "description" -> "Converts an integer value to a floating point value."),
    Map("name" -> "toFloatList", "category" -> LIST, "description" -> "Converts a list of values to a list of float values. If any values are not convertible to float they will be null in the list returned."),
    Map("name" -> "toFloatOrNull", "category" -> SCALAR, "description" -> "Converts a value to a floating point value, or null if the value cannot be converted."),
    Map("name" -> "toInteger", "category" -> SCALAR, "description" -> "Converts a string value to an integer value."),
    Map("name" -> "toInteger", "category" -> SCALAR, "description" -> "Converts a floating point value to an integer value."),
    Map("name" -> "toInteger", "category" -> SCALAR, "description" -> "Converts a boolean to an integer value. TRUE is defined to be 1 and FALSE is defined to be 0."),
    Map("name" -> "toIntegerList", "category" -> LIST, "description" -> "Converts a list of values to a list of integer values. If any values are not convertible to integer they will be null in the list returned."),
    Map("name" -> "toIntegerOrNull", "category" -> SCALAR, "description" -> "Converts a value to an integer value, or null if the value cannot be converted."),
    Map("name" -> "toLower", "category" -> STRING, "description" -> "Returns the original string in lowercase."),
    Map("name" -> "toString", "category" -> STRING, "description" -> "Converts an integer, float, boolean, point or temporal type (i.e. Date, Time, LocalTime, DateTime, LocalDateTime or Duration) value to a string."),
    Map("name" -> "toStringList", "category" -> LIST, "description" -> "Converts a list of values to a list of string values. If any values are not convertible to string they will be null in the list returned."),
    Map("name" -> "toStringOrNull", "category" -> STRING, "description" -> "Converts an integer, float, boolean, point or temporal type (i.e. Date, Time, LocalTime, DateTime, LocalDateTime or Duration) value to a string, or null if the value cannot be converted."),
    Map("name" -> "toUpper", "category" -> STRING, "description" -> "Returns the original string in uppercase."),
    Map("name" -> "trim", "category" -> STRING, "description" -> "Returns the original string with leading and trailing whitespace removed."),
    Map("name" -> "type", "category" -> SCALAR, "description" -> "Returns the string representation of the relationship type.")
  )
  private val userDefinedFunctionsBrief = List(
    Map("name" -> "test.function", "category" -> "", "description" -> ""),
    Map("name" -> "test.functionWithInput", "category" -> "", "description" -> ""),
    Map("name" -> "test.return.latest", "category" -> "", "description" -> "Return the latest number, continuously updating the value."),
  )
  private val allFunctionsBrief = (builtInFunctionsBrief ++ userDefinedFunctionsBrief).sortBy(m => m("name"))
  private def allFunctionsVerbose = List(
    Map("name" -> "abs", "category" -> NUMERIC, "description" -> "Returns the absolute value of an integer.", "signature" -> "abs(input :: INTEGER?) :: (INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: INTEGER?", "type" -> "INTEGER?")), "returnDescription" -> "INTEGER?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "abs", "category" -> NUMERIC, "description" -> "Returns the absolute value of a floating point number.", "signature" -> "abs(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "acos", "category" -> TRIGONOMETRIC, "description" -> "Returns the arccosine of a number in radians.", "signature" -> "acos(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "all", "category" -> PREDICATE, "description" -> "Returns true if the predicate holds for all elements in the given list.", "signature" -> "all(variable :: VARIABLE IN list :: LIST OF ANY? WHERE predicate :: ANY?) :: (BOOLEAN?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "variable", "description" -> "variable :: ANY?", "type" -> "ANY?"), Map("name" -> "list", "description" -> "list :: LIST? OF ANY?", "type" -> "LIST? OF ANY?")), "returnDescription" -> "BOOLEAN?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "any", "category" -> PREDICATE, "description" -> "Returns true if the predicate holds for at least one element in the given list.", "signature" -> "any(variable :: VARIABLE IN list :: LIST OF ANY? WHERE predicate :: ANY?) :: (BOOLEAN?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "variable", "description" -> "variable :: ANY?", "type" -> "ANY?"), Map("name" -> "list", "description" -> "list :: LIST? OF ANY?", "type" -> "LIST? OF ANY?")), "returnDescription" -> "BOOLEAN?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "asin", "category" -> TRIGONOMETRIC, "description" -> "Returns the arcsine of a number in radians.", "signature" -> "asin(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "atan", "category" -> TRIGONOMETRIC, "description" -> "Returns the arctangent of a number in radians.", "signature" -> "atan(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "atan2", "category" -> TRIGONOMETRIC, "description" -> "Returns the arctangent2 of a set of coordinates in radians.", "signature" -> "atan2(y :: FLOAT?, x :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "y", "description" -> "y :: FLOAT?", "type" -> "FLOAT?"), Map("name" -> "x", "description" -> "x :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "avg", "category" -> AGGREGATING, "description" -> "Returns the average of a set of integer values.", "signature" -> "avg(input :: INTEGER?) :: (INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: INTEGER?", "type" -> "INTEGER?")), "returnDescription" -> "INTEGER?", "aggregating" -> true, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "avg", "category" -> AGGREGATING, "description" -> "Returns the average of a set of floating point values.", "signature" -> "avg(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> true, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "avg", "category" -> AGGREGATING, "description" -> "Returns the average of a set of duration values.", "signature" -> "avg(input :: DURATION?) :: (DURATION?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: DURATION?", "type" -> "DURATION?")), "returnDescription" -> "DURATION?", "aggregating" -> true, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "ceil", "category" -> NUMERIC, "description" -> "Returns the smallest floating point number that is greater than or equal to a number and equal to a mathematical integer.", "signature" -> "ceil(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "coalesce", "category" -> SCALAR, "description" -> "Returns the first non-null value in a list of expressions.", "signature" -> "coalesce(input :: ANY?) :: (ANY?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: ANY?", "type" -> "ANY?")), "returnDescription" -> "ANY?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "collect", "category" -> AGGREGATING, "description" -> "Returns a list containing the values returned by an expression.", "signature" -> "collect(input :: ANY?) :: (LIST? OF ANY?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: ANY?", "type" -> "ANY?")), "returnDescription" -> "LIST? OF ANY?", "aggregating" -> true, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "cos", "category" -> TRIGONOMETRIC, "description" -> "Returns the cosine  of a number.", "signature" -> "cos(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "cot", "category" -> TRIGONOMETRIC, "description" -> "Returns the cotangent of a number.", "signature" -> "cot(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "count", "category" -> AGGREGATING, "description" -> "Returns the number of values or rows.", "signature" -> "count(input :: ANY?) :: (INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: ANY?", "type" -> "ANY?")), "returnDescription" -> "INTEGER?", "aggregating" -> true, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "date", "category" -> TEMPORAL, "description" -> "Create a Date instant.", "signature" -> "date(input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (DATE?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "input", "description" -> "input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "DATE?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "date.realtime", "category" -> TEMPORAL, "description" -> "Get the current Date instant using the realtime clock.", "signature" -> "date.realtime(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (DATE?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "timezone", "description" -> "timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "DATE?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "date.statement", "category" -> TEMPORAL, "description" -> "Get the current Date instant using the statement clock.", "signature" -> "date.statement(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (DATE?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "timezone", "description" -> "timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "DATE?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "date.transaction", "category" -> TEMPORAL, "description" -> "Get the current Date instant using the transaction clock.", "signature" -> "date.transaction(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (DATE?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "timezone", "description" -> "timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "DATE?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "date.truncate", "category" -> TEMPORAL, "description" -> "Truncate the input temporal value to a Date instant using the specified unit.", "signature" -> "date.truncate(unit :: STRING?, input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?, fields = null :: MAP?) :: (DATE?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "unit", "description" -> "unit :: STRING?", "type" -> "STRING?"), Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "input", "description" -> "input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?"), Map("default" -> "DefaultParameterValue{value=null, type=MAP?}", "name" -> "fields", "description" -> "fields = null :: MAP?", "type" -> "MAP?")), "returnDescription" -> "DATE?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "datetime", "category" -> TEMPORAL, "description" -> "Create a DateTime instant.", "signature" -> "datetime(input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (DATETIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "input", "description" -> "input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "DATETIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "datetime.fromepoch", "category" -> TEMPORAL, "description" -> "Create a DateTime given the seconds and nanoseconds since the start of the epoch.", "signature" -> "datetime.fromepoch(seconds :: NUMBER?, nanoseconds :: NUMBER?) :: (DATETIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "seconds", "description" -> "seconds :: NUMBER?", "type" -> "NUMBER?"), Map("name" -> "nanoseconds", "description" -> "nanoseconds :: NUMBER?", "type" -> "NUMBER?")), "returnDescription" -> "DATETIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "datetime.fromepochmillis", "category" -> TEMPORAL, "description" -> "Create a DateTime given the milliseconds since the start of the epoch.", "signature" -> "datetime.fromepochmillis(milliseconds :: NUMBER?) :: (DATETIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "milliseconds", "description" -> "milliseconds :: NUMBER?", "type" -> "NUMBER?")), "returnDescription" -> "DATETIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "datetime.realtime", "category" -> TEMPORAL, "description" -> "Get the current DateTime instant using the realtime clock.", "signature" -> "datetime.realtime(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (DATETIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "timezone", "description" -> "timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "DATETIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "datetime.statement", "category" -> TEMPORAL, "description" -> "Get the current DateTime instant using the statement clock.", "signature" -> "datetime.statement(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (DATETIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "timezone", "description" -> "timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "DATETIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "datetime.transaction", "category" -> TEMPORAL, "description" -> "Get the current DateTime instant using the transaction clock.", "signature" -> "datetime.transaction(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (DATETIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "timezone", "description" -> "timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "DATETIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "datetime.truncate", "category" -> TEMPORAL, "description" -> "Truncate the input temporal value to a DateTime instant using the specified unit.", "signature" -> "datetime.truncate(unit :: STRING?, input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?, fields = null :: MAP?) :: (DATETIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "unit", "description" -> "unit :: STRING?", "type" -> "STRING?"), Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "input", "description" -> "input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?"), Map("default" -> "DefaultParameterValue{value=null, type=MAP?}", "name" -> "fields", "description" -> "fields = null :: MAP?", "type" -> "MAP?")), "returnDescription" -> "DATETIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "degrees", "category" -> TRIGONOMETRIC, "description" -> "Converts radians to degrees.", "signature" -> "degrees(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "distance", "category" -> SPATIAL, "description" -> "Returns a floating point number representing the geodesic distance between any two points in the same CRS.", "signature" -> "distance(from :: POINT?, to :: POINT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "from", "description" -> "from :: POINT?", "type" -> "POINT?"), Map("name" -> "to", "description" -> "to :: POINT?", "type" -> "POINT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "duration", "category" -> TEMPORAL, "description" -> "Construct a Duration value.", "signature" -> "duration(input :: ANY?) :: (DURATION?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: ANY?", "type" -> "ANY?")), "returnDescription" -> "DURATION?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "duration.between", "category" -> TEMPORAL, "description" -> "Compute the duration between the 'from' instant (inclusive) and the 'to' instant (exclusive) in logical units.", "signature" -> "duration.between(from :: ANY?, to :: ANY?) :: (DURATION?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "from", "description" -> "from :: ANY?", "type" -> "ANY?"), Map("name" -> "to", "description" -> "to :: ANY?", "type" -> "ANY?")), "returnDescription" -> "DURATION?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "duration.inDays", "category" -> TEMPORAL, "description" -> "Compute the duration between the 'from' instant (inclusive) and the 'to' instant (exclusive) in days.", "signature" -> "duration.inDays(from :: ANY?, to :: ANY?) :: (DURATION?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "from", "description" -> "from :: ANY?", "type" -> "ANY?"), Map("name" -> "to", "description" -> "to :: ANY?", "type" -> "ANY?")), "returnDescription" -> "DURATION?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "duration.inMonths", "category" -> TEMPORAL, "description" -> "Compute the duration between the 'from' instant (inclusive) and the 'to' instant (exclusive) in months.", "signature" -> "duration.inMonths(from :: ANY?, to :: ANY?) :: (DURATION?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "from", "description" -> "from :: ANY?", "type" -> "ANY?"), Map("name" -> "to", "description" -> "to :: ANY?", "type" -> "ANY?")), "returnDescription" -> "DURATION?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "duration.inSeconds", "category" -> TEMPORAL, "description" -> "Compute the duration between the 'from' instant (inclusive) and the 'to' instant (exclusive) in seconds.", "signature" -> "duration.inSeconds(from :: ANY?, to :: ANY?) :: (DURATION?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "from", "description" -> "from :: ANY?", "type" -> "ANY?"), Map("name" -> "to", "description" -> "to :: ANY?", "type" -> "ANY?")), "returnDescription" -> "DURATION?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "e", "category" -> LOGARITHMIC, "description" -> "Returns the base of the natural logarithm, e.", "signature" -> "e() :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "endNode", "category" -> SCALAR, "description" -> "Returns the end node of a relationship.", "signature" -> "endNode(input :: RELATIONSHIP?) :: (NODE?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: RELATIONSHIP?", "type" -> "RELATIONSHIP?")), "returnDescription" -> "NODE?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "exists", "category" -> PREDICATE, "description" -> "Returns true if a match for the pattern exists in the graph, or if the specified property exists in the node, relationship or map.", "signature" -> "exists(input :: ANY?) :: (BOOLEAN?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: ANY?", "type" -> "ANY?")), "returnDescription" -> "BOOLEAN?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "exp", "category" -> LOGARITHMIC, "description" -> "Returns e^n, where e is the base of the natural logarithm, and n is the value of the argument expression.", "signature" -> "exp(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "file", "category" -> SCALAR, "description" -> "Returns the absolute path of the file that LOAD CSV is using.", "signature" -> "file() :: (STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(), "returnDescription" -> "STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "floor", "category" -> NUMERIC, "description" -> "Returns the largest floating point number that is less than or equal to a number and equal to a mathematical integer.", "signature" -> "floor(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "haversin", "category" -> TRIGONOMETRIC, "description" -> "Returns half the versine of a number.", "signature" -> "haversin(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "head", "category" -> SCALAR, "description" -> "Returns the first element in a list.", "signature" -> "head(list :: LIST? OF ANY?) :: (ANY?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "list", "description" -> "list :: LIST? OF ANY?", "type" -> "LIST? OF ANY?")), "returnDescription" -> "ANY?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "id", "category" -> SCALAR, "description" -> "Returns the id of a node.", "signature" -> "id(input :: NODE?) :: (INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: NODE?", "type" -> "NODE?")), "returnDescription" -> "INTEGER?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "id", "category" -> SCALAR, "description" -> "Returns the id of a relationship.", "signature" -> "id(input :: RELATIONSHIP?) :: (INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: RELATIONSHIP?", "type" -> "RELATIONSHIP?")), "returnDescription" -> "INTEGER?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "isEmpty", "category" -> PREDICATE, "description" -> "Checks whether a list is empty.", "signature" -> "isEmpty(input :: LIST? OF ANY?) :: (BOOLEAN?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: LIST? OF ANY?", "type" -> "LIST? OF ANY?")), "returnDescription" -> "BOOLEAN?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "isEmpty", "category" -> PREDICATE, "description" -> "Checks whether a map is empty.", "signature" -> "isEmpty(input :: MAP?) :: (BOOLEAN?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: MAP?", "type" -> "MAP?")), "returnDescription" -> "BOOLEAN?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "isEmpty", "category" -> PREDICATE, "description" -> "Checks whether a string is empty.", "signature" -> "isEmpty(input :: STRING?) :: (BOOLEAN?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: STRING?", "type" -> "STRING?")), "returnDescription" -> "BOOLEAN?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "keys", "category" -> LIST, "description" -> "Returns a list containing the string representations for all the property names of a node.", "signature" -> "keys(input :: NODE?) :: (LIST? OF STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: NODE?", "type" -> "NODE?")), "returnDescription" -> "LIST? OF STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "keys", "category" -> LIST, "description" -> "Returns a list containing the string representations for all the property names of a relationship", "signature" -> "keys(input :: RELATIONSHIP?) :: (LIST? OF STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: RELATIONSHIP?", "type" -> "RELATIONSHIP?")), "returnDescription" -> "LIST? OF STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "keys", "category" -> LIST, "description" -> "Returns a list containing the string representations for all the property names of a map.", "signature" -> "keys(input :: MAP?) :: (LIST? OF STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: MAP?", "type" -> "MAP?")), "returnDescription" -> "LIST? OF STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "labels", "category" -> LIST, "description" -> "Returns a list containing the string representations for all the labels of a node.", "signature" -> "labels(input :: NODE?) :: (LIST? OF STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: NODE?", "type" -> "NODE?")), "returnDescription" -> "LIST? OF STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "last", "category" -> SCALAR, "description" -> "Returns the last element in a list.", "signature" -> "last(list :: LIST? OF ANY?) :: (ANY?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "list", "description" -> "list :: LIST? OF ANY?", "type" -> "LIST? OF ANY?")), "returnDescription" -> "ANY?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "left", "category" -> STRING, "description" -> "Returns a string containing the specified number of leftmost characters of the original string.", "signature" -> "left(original :: STRING?, length :: INTEGER?) :: (STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "original", "description" -> "original :: STRING?", "type" -> "STRING?"), Map("name" -> "length", "description" -> "length :: INTEGER?", "type" -> "INTEGER?")), "returnDescription" -> "STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "length", "category" -> SCALAR, "description" -> "Returns the length of a path.", "signature" -> "length(input :: PATH?) :: (INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: PATH?", "type" -> "PATH?")), "returnDescription" -> "INTEGER?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "linenumber", "category" -> SCALAR, "description" -> "Returns the line number that LOAD CSV is currently using.", "signature" -> "linenumber() :: (INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(), "returnDescription" -> "INTEGER?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "localdatetime", "category" -> TEMPORAL, "description" -> "Create a LocalDateTime instant.", "signature" -> "localdatetime(input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (LOCALDATETIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "input", "description" -> "input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "LOCALDATETIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "localdatetime.realtime", "category" -> TEMPORAL, "description" -> "Get the current LocalDateTime instant using the realtime clock.", "signature" -> "localdatetime.realtime(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (LOCALDATETIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "timezone", "description" -> "timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "LOCALDATETIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "localdatetime.statement", "category" -> TEMPORAL, "description" -> "Get the current LocalDateTime instant using the statement clock.", "signature" -> "localdatetime.statement(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (LOCALDATETIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "timezone", "description" -> "timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "LOCALDATETIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "localdatetime.transaction", "category" -> TEMPORAL, "description" -> "Get the current LocalDateTime instant using the transaction clock.", "signature" -> "localdatetime.transaction(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (LOCALDATETIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "timezone", "description" -> "timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "LOCALDATETIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "localdatetime.truncate", "category" -> TEMPORAL, "description" -> "Truncate the input temporal value to a LocalDateTime instant using the specified unit.", "signature" -> "localdatetime.truncate(unit :: STRING?, input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?, fields = null :: MAP?) :: (LOCALDATETIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "unit", "description" -> "unit :: STRING?", "type" -> "STRING?"), Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "input", "description" -> "input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?"), Map("default" -> "DefaultParameterValue{value=null, type=MAP?}", "name" -> "fields", "description" -> "fields = null :: MAP?", "type" -> "MAP?")), "returnDescription" -> "LOCALDATETIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "localtime", "category" -> TEMPORAL, "description" -> "Create a LocalTime instant.", "signature" -> "localtime(input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (LOCALTIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "input", "description" -> "input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "LOCALTIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "localtime.realtime", "category" -> TEMPORAL, "description" -> "Get the current LocalTime instant using the realtime clock.", "signature" -> "localtime.realtime(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (LOCALTIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "timezone", "description" -> "timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "LOCALTIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "localtime.statement", "category" -> TEMPORAL, "description" -> "Get the current LocalTime instant using the statement clock.", "signature" -> "localtime.statement(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (LOCALTIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "timezone", "description" -> "timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "LOCALTIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "localtime.transaction", "category" -> TEMPORAL, "description" -> "Get the current LocalTime instant using the transaction clock.", "signature" -> "localtime.transaction(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (LOCALTIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "timezone", "description" -> "timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "LOCALTIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "localtime.truncate", "category" -> TEMPORAL, "description" -> "Truncate the input temporal value to a LocalTime instant using the specified unit.", "signature" -> "localtime.truncate(unit :: STRING?, input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?, fields = null :: MAP?) :: (LOCALTIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "unit", "description" -> "unit :: STRING?", "type" -> "STRING?"), Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "input", "description" -> "input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?"), Map("default" -> "DefaultParameterValue{value=null, type=MAP?}", "name" -> "fields", "description" -> "fields = null :: MAP?", "type" -> "MAP?")), "returnDescription" -> "LOCALTIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "log", "category" -> LOGARITHMIC, "description" -> "Returns the natural logarithm of a number.", "signature" -> "log(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "log10", "category" -> LOGARITHMIC, "description" -> "Returns the common logarithm (base 10) of a number.", "signature" -> "log10(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "ltrim", "category" -> STRING, "description" -> "Returns the original string with leading whitespace removed.", "signature" -> "ltrim(input :: STRING?) :: (STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: STRING?", "type" -> "STRING?")), "returnDescription" -> "STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "max", "category" -> AGGREGATING, "description" -> "Returns the maximum value in a set of values.", "signature" -> "max(input :: ANY?) :: (ANY?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: ANY?", "type" -> "ANY?")), "returnDescription" -> "ANY?", "aggregating" -> true, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "min", "category" -> AGGREGATING, "description" -> "Returns the minimum value in a set of values.", "signature" -> "min(input :: ANY?) :: (ANY?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: ANY?", "type" -> "ANY?")), "returnDescription" -> "ANY?", "aggregating" -> true, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "nodes", "category" -> LIST, "description" -> "Returns a list containing all the nodes in a path.", "signature" -> "nodes(input :: PATH?) :: (LIST? OF NODE?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: PATH?", "type" -> "PATH?")), "returnDescription" -> "LIST? OF NODE?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "none", "category" -> PREDICATE, "description" -> "Returns true if the predicate holds for no element in the given list.", "signature" -> "none(variable :: VARIABLE IN list :: LIST OF ANY? WHERE predicate :: ANY?) :: (BOOLEAN?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "variable", "description" -> "variable :: ANY?", "type" -> "ANY?"), Map("name" -> "list", "description" -> "list :: LIST? OF ANY?", "type" -> "LIST? OF ANY?")), "returnDescription" -> "BOOLEAN?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "percentileCont", "category" -> AGGREGATING, "description" -> "Returns the percentile of a value over a group using linear interpolation.", "signature" -> "percentileCont(input :: FLOAT?, percentile :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?"), Map("name" -> "percentile", "description" -> "percentile :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> true, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "percentileDisc", "category" -> AGGREGATING, "description" -> "Returns the nearest integer value to the given percentile over a group using a rounding method.", "signature" -> "percentileDisc(input :: INTEGER?, percentile :: FLOAT?) :: (INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "percentile", "description" -> "percentile :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "INTEGER?", "aggregating" -> true, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "percentileDisc", "category" -> AGGREGATING, "description" -> "Returns the nearest floating point value to the given percentile over a group using a rounding method.", "signature" -> "percentileDisc(input :: FLOAT?, percentile :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?"), Map("name" -> "percentile", "description" -> "percentile :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> true, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "pi", "category" -> TRIGONOMETRIC, "description" -> "Returns the mathematical constant pi.", "signature" -> "pi() :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "point", "category" -> SPATIAL, "description" -> "Returns a 2D or 3D point object, given two or respectively three coordinate values in the Cartesian coordinate system or WGS 84 geographic coordinate system.", "signature" -> "point(input :: MAP?) :: (POINT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: MAP?", "type" -> "MAP?")), "returnDescription" -> "POINT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "properties", "category" -> SCALAR, "description" -> "Returns a map containing all the properties of a node.", "signature" -> "properties(input :: NODE?) :: (MAP?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: NODE?", "type" -> "NODE?")), "returnDescription" -> "MAP?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "properties", "category" -> SCALAR, "description" -> "Returns a map containing all the properties of a relationship.", "signature" -> "properties(input :: RELATIONSHIP?) :: (MAP?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: RELATIONSHIP?", "type" -> "RELATIONSHIP?")), "returnDescription" -> "MAP?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "properties", "category" -> SCALAR, "description" -> "Returns a map containing all the properties of a map.", "signature" -> "properties(input :: MAP?) :: (MAP?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: MAP?", "type" -> "MAP?")), "returnDescription" -> "MAP?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "radians", "category" -> TRIGONOMETRIC, "description" -> "Converts degrees to radians.", "signature" -> "radians(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "rand", "category" -> NUMERIC, "description" -> "Returns a random floating point number in the range from 0 (inclusive) to 1 (exclusive); i.e. [0,1).", "signature" -> "rand() :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "randomUUID", "category" -> SCALAR, "description" -> "Generates a random UUID.", "signature" -> "randomUUID() :: (STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(), "returnDescription" -> "STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "range", "category" -> LIST, "description" -> "Returns a list comprising all integer values within a specified range.", "signature" -> "range(start :: INTEGER?, end :: INTEGER?) :: (LIST? OF INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "start", "description" -> "start :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "end", "description" -> "end :: INTEGER?", "type" -> "INTEGER?")), "returnDescription" -> "LIST? OF INTEGER?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "range", "category" -> LIST, "description" -> "Returns a list comprising all integer values within a specified range created with step length.", "signature" -> "range(start :: INTEGER?, end :: INTEGER?, step :: INTEGER?) :: (LIST? OF INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "start", "description" -> "start :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "end", "description" -> "end :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "step", "description" -> "step :: INTEGER?", "type" -> "INTEGER?")), "returnDescription" -> "LIST? OF INTEGER?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "reduce", "category" -> LIST, "description" -> "Runs an expression against individual elements of a list, storing the result of the expression in an accumulator.", "signature" -> "reduce(accumulator :: VARIABLE = initial :: ANY?, variable :: VARIABLE IN list :: LIST OF ANY? | expression :: ANY) :: (ANY?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "accumulator", "description" -> "accumulator :: ANY?", "type" -> "ANY?"), Map("name" -> "variable", "description" -> "variable :: LIST? OF ANY?", "type" -> "LIST? OF ANY?")), "returnDescription" -> "ANY?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "relationships", "category" -> LIST, "description" -> "Returns a list containing all the relationships in a path.", "signature" -> "relationships(input :: PATH?) :: (LIST? OF RELATIONSHIP?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: PATH?", "type" -> "PATH?")), "returnDescription" -> "LIST? OF RELATIONSHIP?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "replace", "category" -> STRING, "description" -> "Returns a string in which all occurrences of a specified search string in the original string have been replaced by another (specified) replace string.", "signature" -> "replace(original :: STRING?, search :: STRING?, replace :: STRING?) :: (STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "original", "description" -> "original :: STRING?", "type" -> "STRING?"), Map("name" -> "search", "description" -> "search :: STRING?", "type" -> "STRING?"), Map("name" -> "replace", "description" -> "replace :: STRING?", "type" -> "STRING?")), "returnDescription" -> "STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "reverse", "category" -> STRING, "description" -> "Returns a string in which the order of all characters in the original string have been reversed.", "signature" -> "reverse(input :: STRING?) :: (STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: STRING?", "type" -> "STRING?")), "returnDescription" -> "STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "reverse", "category" -> LIST, "description" -> "Returns a list in which the order of all elements in the original list have been reversed.", "signature" -> "reverse(input :: LIST? OF ANY?) :: (LIST? OF ANY?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: LIST? OF ANY?", "type" -> "LIST? OF ANY?")), "returnDescription" -> "LIST? OF ANY?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "right", "category" -> STRING, "description" -> "Returns a string containing the specified number of rightmost characters of the original string.", "signature" -> "right(original :: STRING?, length :: INTEGER?) :: (STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "original", "description" -> "original :: STRING?", "type" -> "STRING?"), Map("name" -> "length", "description" -> "length :: INTEGER?", "type" -> "INTEGER?")), "returnDescription" -> "STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "round", "category" -> NUMERIC, "description" -> "Returns the value of a number rounded to the nearest integer.", "signature" -> "round(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "round", "category" -> NUMERIC, "description" -> "Returns the value of a number rounded to the specified precision using rounding mode HALF_UP.", "signature" -> "round(value :: FLOAT?, precision :: NUMBER?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "value", "description" -> "value :: FLOAT?", "type" -> "FLOAT?"), Map("name" -> "precision", "description" -> "precision :: NUMBER?", "type" -> "NUMBER?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "round", "category" -> NUMERIC, "description" -> "Returns the value of a number rounded to the specified precision with the specified rounding mode.", "signature" -> "round(value :: FLOAT?, precision :: NUMBER?, mode :: STRING?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "value", "description" -> "value :: FLOAT?", "type" -> "FLOAT?"), Map("name" -> "precision", "description" -> "precision :: NUMBER?", "type" -> "NUMBER?"), Map("name" -> "mode", "description" -> "mode :: STRING?", "type" -> "STRING?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "rtrim", "category" -> STRING, "description" -> "Returns the original string with trailing whitespace removed.", "signature" -> "rtrim(input :: STRING?) :: (STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: STRING?", "type" -> "STRING?")), "returnDescription" -> "STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "sign", "category" -> NUMERIC, "description" -> "Returns the signum of an integer number: 0 if the number is 0, -1 for any negative number, and 1 for any positive number.", "signature" -> "sign(input :: INTEGER?) :: (INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: INTEGER?", "type" -> "INTEGER?")), "returnDescription" -> "INTEGER?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "sign", "category" -> NUMERIC, "description" -> "Returns the signum of a floating point number: 0 if the number is 0, -1 for any negative number, and 1 for any positive number.", "signature" -> "sign(input :: FLOAT?) :: (INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "INTEGER?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "sin", "category" -> TRIGONOMETRIC, "description" -> "Returns the sine of a number.", "signature" -> "sin(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "single", "category" -> PREDICATE, "description" -> "Returns true if the predicate holds for exactly one of the elements in the given list.", "signature" -> "single(variable :: VARIABLE IN list :: LIST OF ANY? WHERE predicate :: ANY?) :: (BOOLEAN?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "variable", "description" -> "variable :: ANY?", "type" -> "ANY?"), Map("name" -> "list", "description" -> "list :: LIST? OF ANY?", "type" -> "LIST? OF ANY?")), "returnDescription" -> "BOOLEAN?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "size", "category" -> SCALAR, "description" -> "Returns the number of items in a list.", "signature" -> "size(input :: LIST? OF ANY?) :: (INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: LIST? OF ANY?", "type" -> "LIST? OF ANY?")), "returnDescription" -> "INTEGER?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "size", "category" -> SCALAR, "description" -> "Returns the number of Unicode characters in a string.", "signature" -> "size(input :: STRING?) :: (INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: STRING?", "type" -> "STRING?")), "returnDescription" -> "INTEGER?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "split", "category" -> STRING, "description" -> "Returns a list of strings resulting from the splitting of the original string around matches of the given delimiter.", "signature" -> "split(original :: STRING?, splitDelimiter :: STRING?) :: (LIST? OF STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "original", "description" -> "original :: STRING?", "type" -> "STRING?"), Map("name" -> "splitDelimiter", "description" -> "splitDelimiter :: STRING?", "type" -> "STRING?")), "returnDescription" -> "LIST? OF STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "split", "category" -> STRING, "description" -> "Returns a list of strings resulting from the splitting of the original string around matches of any of the given delimiters.", "signature" -> "split(original :: STRING?, splitDelimiters :: LIST? OF STRING?) :: (LIST? OF STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "original", "description" -> "original :: STRING?", "type" -> "STRING?"), Map("name" -> "splitDelimiters", "description" -> "splitDelimiters :: LIST? OF STRING?", "type" -> "LIST? OF STRING?")), "returnDescription" -> "LIST? OF STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "sqrt", "category" -> LOGARITHMIC, "description" -> "Returns the square root of a number.", "signature" -> "sqrt(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "startNode", "category" -> SCALAR, "description" -> "Returns the start node of a relationship.", "signature" -> "startNode(input :: RELATIONSHIP?) :: (NODE?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: RELATIONSHIP?", "type" -> "RELATIONSHIP?")), "returnDescription" -> "NODE?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "stdev", "category" -> AGGREGATING, "description" -> "Returns the standard deviation for the given value over a group for a sample of a population.", "signature" -> "stdev(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> true, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "stdevp", "category" -> AGGREGATING, "description" -> "Returns the standard deviation for the given value over a group for an entire population.", "signature" -> "stdevp(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> true, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "substring", "category" -> STRING, "description" -> "Returns a substring of the original string, beginning with a 0-based index start.", "signature" -> "substring(original :: STRING?, start :: INTEGER?) :: (STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "original", "description" -> "original :: STRING?", "type" -> "STRING?"), Map("name" -> "start", "description" -> "start :: INTEGER?", "type" -> "INTEGER?")), "returnDescription" -> "STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "substring", "category" -> STRING, "description" -> "Returns a substring of length 'length' of the original string, beginning with a 0-based index start.", "signature" -> "substring(original :: STRING?, start :: INTEGER?, length :: INTEGER?) :: (STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "original", "description" -> "original :: STRING?", "type" -> "STRING?"), Map("name" -> "start", "description" -> "start :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "length", "description" -> "length :: INTEGER?", "type" -> "INTEGER?")), "returnDescription" -> "STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "sum", "category" -> AGGREGATING, "description" -> "Returns the sum of a set of integers", "signature" -> "sum(input :: INTEGER?) :: (INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: INTEGER?", "type" -> "INTEGER?")), "returnDescription" -> "INTEGER?", "aggregating" -> true, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "sum", "category" -> AGGREGATING, "description" -> "Returns the sum of a set of floats", "signature" -> "sum(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> true, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "sum", "category" -> AGGREGATING, "description" -> "Returns the sum of a set of durations", "signature" -> "sum(input :: DURATION?) :: (DURATION?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: DURATION?", "type" -> "DURATION?")), "returnDescription" -> "DURATION?", "aggregating" -> true, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "tail", "category" -> LIST, "description" -> "Returns all but the first element in a list.", "signature" -> "tail(input :: LIST? OF ANY?) :: (LIST? OF ANY?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: LIST? OF ANY?", "type" -> "LIST? OF ANY?")), "returnDescription" -> "LIST? OF ANY?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "tan", "category" -> TRIGONOMETRIC, "description" -> "Returns the tangent of a number.", "signature" -> "tan(input :: FLOAT?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: FLOAT?", "type" -> "FLOAT?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "test.function", "category" -> "", "description" -> "", "signature" -> "test.function() :: (STRING?)", "isBuiltIn" -> false, "argumentDescription" -> List(), "returnDescription" -> "STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "test.functionWithInput", "category" -> "", "description" -> "", "signature" -> "test.functionWithInput(input :: STRING?) :: (LIST? OF ANY?)", "isBuiltIn" -> false, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: STRING?", "type" -> "STRING?")), "returnDescription" -> "LIST? OF ANY?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "test.return.latest", "category" -> "", "description" -> "Return the latest number, continuously updating the value.", "signature" -> "test.return.latest(value :: INTEGER?) :: (INTEGER?)", "isBuiltIn" -> false, "argumentDescription" -> List(Map("name" -> "value", "description" -> "value :: INTEGER?", "type" -> "INTEGER?")), "returnDescription" -> "INTEGER?", "aggregating" -> true, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "time", "category" -> TEMPORAL, "description" -> "Create a Time instant.", "signature" -> "time(input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (TIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "input", "description" -> "input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "TIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "time.realtime", "category" -> TEMPORAL, "description" -> "Get the current Time instant using the realtime clock.", "signature" -> "time.realtime(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (TIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "timezone", "description" -> "timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "TIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "time.statement", "category" -> TEMPORAL, "description" -> "Get the current Time instant using the statement clock.", "signature" -> "time.statement(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (TIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "timezone", "description" -> "timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "TIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "time.transaction", "category" -> TEMPORAL, "description" -> "Get the current Time instant using the transaction clock.", "signature" -> "time.transaction(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (TIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "timezone", "description" -> "timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?")), "returnDescription" -> "TIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "time.truncate", "category" -> TEMPORAL, "description" -> "Truncate the input temporal value to a Time instant using the specified unit.", "signature" -> "time.truncate(unit :: STRING?, input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?, fields = null :: MAP?) :: (TIME?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "unit", "description" -> "unit :: STRING?", "type" -> "STRING?"), Map("default" -> "DefaultParameterValue{value=DEFAULT_TEMPORAL_ARGUMENT, type=ANY?}", "name" -> "input", "description" -> "input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?", "type" -> "ANY?"), Map("default" -> "DefaultParameterValue{value=null, type=MAP?}", "name" -> "fields", "description" -> "fields = null :: MAP?", "type" -> "MAP?")), "returnDescription" -> "TIME?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toBoolean", "category" -> SCALAR, "description" -> "Converts a string value to a boolean value.", "signature" -> "toBoolean(input :: STRING?) :: (BOOLEAN?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: STRING?", "type" -> "STRING?")), "returnDescription" -> "BOOLEAN?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toBoolean", "category" -> SCALAR, "description" -> "Converts a boolean value to a boolean value.", "signature" -> "toBoolean(input :: BOOLEAN?) :: (BOOLEAN?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: BOOLEAN?", "type" -> "BOOLEAN?")), "returnDescription" -> "BOOLEAN?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toBoolean", "category" -> SCALAR, "description" -> "Converts a integer value to a boolean value. 0 is defined to be FALSE and any other integer is defined to be TRUE.", "signature" -> "toBoolean(input :: INTEGER?) :: (BOOLEAN?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: INTEGER?", "type" -> "INTEGER?")), "returnDescription" -> "BOOLEAN?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toBooleanList", "category" -> LIST, "description" -> "Converts a list of values to a list of boolean values. If any values are not convertible to boolean they will be null in the list returned.", "signature" -> "toBooleanList(input :: LIST? OF ANY?) :: (LIST? OF BOOLEAN?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: LIST? OF ANY?", "type" -> "LIST? OF ANY?")), "returnDescription" -> "LIST? OF BOOLEAN?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toBooleanOrNull", "category" -> SCALAR, "description" -> "Converts a value to a boolean value, or null if the value cannot be converted.", "signature" -> "toBooleanOrNull(input :: ANY?) :: (BOOLEAN?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: ANY?", "type" -> "ANY?")), "returnDescription" -> "BOOLEAN?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toFloat", "category" -> SCALAR, "description" -> "Converts a string value to a floating point value.", "signature" -> "toFloat(input :: STRING?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: STRING?", "type" -> "STRING?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toFloat", "category" -> SCALAR, "description" -> "Converts an integer value to a floating point value.", "signature" -> "toFloat(input :: NUMBER?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: NUMBER?", "type" -> "NUMBER?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toFloatList", "category" -> LIST, "description" -> "Converts a list of values to a list of float values. If any values are not convertible to float they will be null in the list returned.", "signature" -> "toFloatList(input :: LIST? OF ANY?) :: (LIST? OF FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: LIST? OF ANY?", "type" -> "LIST? OF ANY?")), "returnDescription" -> "LIST? OF FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toFloatOrNull", "category" -> SCALAR, "description" -> "Converts a value to a floating point value, or null if the value cannot be converted.", "signature" -> "toFloatOrNull(input :: ANY?) :: (FLOAT?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: ANY?", "type" -> "ANY?")), "returnDescription" -> "FLOAT?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toInteger", "category" -> SCALAR, "description" -> "Converts a string value to an integer value.", "signature" -> "toInteger(input :: STRING?) :: (INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: STRING?", "type" -> "STRING?")), "returnDescription" -> "INTEGER?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toInteger", "category" -> SCALAR, "description" -> "Converts a floating point value to an integer value.", "signature" -> "toInteger(input :: NUMBER?) :: (INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: NUMBER?", "type" -> "NUMBER?")), "returnDescription" -> "INTEGER?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toInteger", "category" -> SCALAR, "description" -> "Converts a boolean to an integer value. TRUE is defined to be 1 and FALSE is defined to be 0.", "signature" -> "toInteger(input :: BOOLEAN?) :: (INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: BOOLEAN?", "type" -> "BOOLEAN?")), "returnDescription" -> "INTEGER?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toIntegerList", "category" -> LIST, "description" -> "Converts a list of values to a list of integer values. If any values are not convertible to integer they will be null in the list returned.", "signature" -> "toIntegerList(input :: LIST? OF ANY?) :: (LIST? OF INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: LIST? OF ANY?", "type" -> "LIST? OF ANY?")), "returnDescription" -> "LIST? OF INTEGER?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toIntegerOrNull", "category" -> SCALAR, "description" -> "Converts a value to an integer value, or null if the value cannot be converted.", "signature" -> "toIntegerOrNull(input :: ANY?) :: (INTEGER?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: ANY?", "type" -> "ANY?")), "returnDescription" -> "INTEGER?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toLower", "category" -> STRING, "description" -> "Returns the original string in lowercase.", "signature" -> "toLower(input :: STRING?) :: (STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: STRING?", "type" -> "STRING?")), "returnDescription" -> "STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toString", "category" -> STRING, "description" -> "Converts an integer, float, boolean, point or temporal type (i.e. Date, Time, LocalTime, DateTime, LocalDateTime or Duration) value to a string.", "signature" -> "toString(input :: ANY?) :: (STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: ANY?", "type" -> "ANY?")), "returnDescription" -> "STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toStringList", "category" -> LIST, "description" -> "Converts a list of values to a list of string values. If any values are not convertible to string they will be null in the list returned.", "signature" -> "toStringList(input :: LIST? OF ANY?) :: (LIST? OF STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: LIST? OF ANY?", "type" -> "LIST? OF ANY?")), "returnDescription" -> "LIST? OF STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toStringOrNull", "category" -> STRING, "description" -> "Converts an integer, float, boolean, point or temporal type (i.e. Date, Time, LocalTime, DateTime, LocalDateTime or Duration) value to a string, or null if the value cannot be converted.", "signature" -> "toStringOrNull(input :: ANY?) :: (STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: ANY?", "type" -> "ANY?")), "returnDescription" -> "STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "toUpper", "category" -> STRING, "description" -> "Returns the original string in uppercase.", "signature" -> "toUpper(input :: STRING?) :: (STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: STRING?", "type" -> "STRING?")), "returnDescription" -> "STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "trim", "category" -> STRING, "description" -> "Returns the original string with leading and trailing whitespace removed.", "signature" -> "trim(input :: STRING?) :: (STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: STRING?", "type" -> "STRING?")), "returnDescription" -> "STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null),
    Map("name" -> "type", "category" -> SCALAR, "description" -> "Returns the string representation of the relationship type.", "signature" -> "type(input :: RELATIONSHIP?) :: (STRING?)", "isBuiltIn" -> true, "argumentDescription" -> List(Map("name" -> "input", "description" -> "input :: RELATIONSHIP?", "type" -> "RELATIONSHIP?")), "returnDescription" -> "STRING?", "aggregating" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null)
  )

  test("should show functions") {
    // GIVEN
    selectDatabase(DEFAULT_DATABASE_NAME)

    // WHEN
    val result = execute("SHOW FUNCTIONS")

    // THEN
    result.toList should be(allFunctionsBrief)
  }

  test("should show built-in functions") {
    // GIVEN
    selectDatabase(DEFAULT_DATABASE_NAME)

    // WHEN
    val result = execute("SHOW BUILT IN FUNCTIONS")

    // THEN
    result.toList should be(builtInFunctionsBrief)
  }

  test("should show user-defined functions") {
    // GIVEN
    selectDatabase(DEFAULT_DATABASE_NAME)

    // WHEN
    val result = execute("SHOW USER DEFINED FUNCTIONS")

    // THEN
    result.toList should be(userDefinedFunctionsBrief)
  }

  test("should show functions with yield") {
    // GIVEN
    selectDatabase(DEFAULT_DATABASE_NAME)

    // WHEN
    val result = execute("SHOW FUNCTIONS YIELD *")

    // THEN
    result.toList should be(allFunctionsVerbose)
  }

  test("should show functions executable by current user") {
    // GIVEN
    createUser()

    // WHEN
    val result = executeAs(username, password, "SHOW FUNCTIONS EXECUTABLE")

    // THEN
    result.toList should be(allFunctionsBrief)
  }

  test("should show functions executable by current user with yield") {
    // GIVEN
    createUser()

    // WHEN
    val result = executeAs(username, password, "SHOW FUNCTIONS EXECUTABLE YIELD name, description, isBuiltIn")

    // THEN
    result.toList should be(allFunctionsVerbose.map(m => m.filterKeys(k => Seq("name", "description", "isBuiltIn").contains(k))))
  }

  test("should show functions executable by specified user") {
    // GIVEN
    createUser()

    // WHEN
    val result = execute(s"SHOW FUNCTIONS EXECUTABLE BY $username")

    // THEN
    result.toList should be(allFunctionsBrief)
  }

  test("should show functions executable by specified user with yield") {
    // GIVEN
    createUser()

    // WHEN
    val result = execute(s"SHOW FUNCTIONS EXECUTABLE BY $username YIELD *")

    // THEN
    result.toList should be(allFunctionsVerbose)
  }

  test("should show functions on system") {
    // GIVEN
    selectDatabase(SYSTEM_DATABASE_NAME)

    // WHEN
    val result = execute("SHOW FUNCTIONS")

    // THEN
    result.toList should be(allFunctionsBrief)
  }

  // SHOW PROCEDURES

  private val allProceduresBrief = List(
    Map("name" -> "db.awaitIndex", "description" -> """Wait for an index to come online (for example: CALL db.awaitIndex("MyIndex", 300)).""", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.awaitIndexes", "description" -> "Wait for all indexes to come online (for example: CALL db.awaitIndexes(300)).", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.clearQueryCaches", "description" -> "Clears all query caches.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "db.constraints", "description" -> "List all constraints in the database.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.createIndex", "description" -> "Create a named schema index with specified index provider and configuration (optional). Yield: name, labels, properties, providerName, status", "mode" -> SCHEMA.toString, "worksOnSystem" -> false),
    Map("name" -> "db.createLabel", "description" -> "Create a label", "mode" -> WRITE.toString, "worksOnSystem" -> false),
    Map("name" -> "db.createProperty", "description" -> "Create a Property", "mode" -> WRITE.toString, "worksOnSystem" -> false),
    Map("name" -> "db.createRelationshipType", "description" -> "Create a RelationshipType", "mode" -> WRITE.toString, "worksOnSystem" -> false),
    Map("name" -> "db.createUniquePropertyConstraint", "description" -> "Create a named unique property constraint. Backing index will use specified index provider and configuration (optional). Yield: name, labels, properties, providerName, status", "mode" -> SCHEMA.toString, "worksOnSystem" -> false),
    Map("name" -> "db.index.fulltext.awaitEventuallyConsistentIndexRefresh", "description" -> "Wait for the updates from recently committed transactions to be applied to any eventually-consistent full-text indexes.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.index.fulltext.createNodeIndex", "description" -> "Create a node full-text index for the given labels and properties. The optional 'config' map parameter can be used to supply settings to the index. Supported settings are 'analyzer', for specifying what analyzer to use when indexing and querying. Use the `db.index.fulltext.listAvailableAnalyzers` procedure to see what options are available. And 'eventually_consistent' which can be set to 'true' to make this index eventually consistent, such that updates from committing transactions are applied in a background thread.", "mode" -> SCHEMA.toString, "worksOnSystem" -> false),
    Map("name" -> "db.index.fulltext.createRelationshipIndex", "description" -> "Create a relationship full-text index for the given relationship types and properties. The optional 'config' map parameter can be used to supply settings to the index. Supported settings are 'analyzer', for specifying what analyzer to use when indexing and querying. Use the `db.index.fulltext.listAvailableAnalyzers` procedure to see what options are available. And 'eventually_consistent' which can be set to 'true' to make this index eventually consistent, such that updates from committing transactions are applied in a background thread.", "mode" -> SCHEMA.toString, "worksOnSystem" -> false),
    Map("name" -> "db.index.fulltext.drop", "description" -> "Drop the specified index.", "mode" -> SCHEMA.toString, "worksOnSystem" -> false),
    Map("name" -> "db.index.fulltext.listAvailableAnalyzers", "description" -> "List the available analyzers that the full-text indexes can be configured with.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.index.fulltext.queryNodes", "description" -> "Query the given full-text index. Returns the matching nodes, and their Lucene query score, ordered by score. Valid keys for the options map are: 'skip' to skip the top N results; 'limit' to limit the number of results returned.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.index.fulltext.queryRelationships", "description" -> "Query the given full-text index. Returns the matching relationships, and their Lucene query score, ordered by score. Valid keys for the options map are: 'skip' to skip the top N results; 'limit' to limit the number of results returned.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.indexDetails", "description" -> "Detailed description of specific index.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.indexes", "description" -> "List all indexes in the database.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.info", "description" -> "Provides information regarding the database.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.labels", "description" -> "List all available labels in the database.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.ping", "description" -> "This procedure can be used by client side tooling to test whether they are correctly connected to a database. The procedure is available in all databases and always returns true. A faulty connection can be detected by not being able to call this procedure.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.prepareForReplanning", "description" -> "Triggers an index resample and waits for it to complete, and after that clears query caches. After this procedure has finished queries will be planned using the latest database statistics.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.propertyKeys", "description" -> "List all property keys in the database.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.relationshipTypes", "description" -> "List all available relationship types in the database.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.resampleIndex", "description" -> """Schedule resampling of an index (for example: CALL db.resampleIndex("MyIndex")).""", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.resampleOutdatedIndexes", "description" -> "Schedule resampling of all outdated indexes.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.schema.nodeTypeProperties", "description" -> "Show the derived property schema of the nodes in tabular form.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.schema.relTypeProperties", "description" -> "Show the derived property schema of the relationships in tabular form.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.schema.visualization", "description" -> "Visualize the schema of the data.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.schemaStatements", "description" -> "List all statements for creating and dropping existing indexes and constraints. Note that only index types introduced before Neo4j 4.3 are included.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.stats.clear", "description" -> "Clear collected data of a given data section. Valid sections are 'QUERIES'", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.stats.collect", "description" -> "Start data collection of a given data section. Valid sections are 'QUERIES'", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.stats.retrieve", "description" -> "Retrieve statistical data about the current database. Valid sections are 'GRAPH COUNTS', 'TOKENS', 'QUERIES', 'META'", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.stats.retrieveAllAnonymized", "description" -> "Retrieve all available statistical data about the current database, in an anonymized form.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.stats.status", "description" -> "Retrieve the status of all available collector daemons, for this database.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "db.stats.stop", "description" -> "Stop data collection of a given data section. Valid sections are 'QUERIES'", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.cluster.routing.getRoutingTable", "description" -> "Returns endpoints of this instance.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.components", "description" -> "List DBMS components and their versions.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.database.state", "description" -> "The actual status of the database with the provided name on this neo4j instance.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.functions", "description" -> "List all functions in the DBMS.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.info", "description" -> "Provides information regarding the DBMS.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.killConnection", "description" -> "Kill network connection with the given connection id.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.killConnections", "description" -> "Kill all network connections with the given connection ids.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.killQueries", "description" -> "Kill all transactions executing a query with any of the given query ids.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.killQuery", "description" -> "Kill all transactions executing the query with the given query id.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.killTransaction", "description" -> "Kill transaction with provided id.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.killTransactions", "description" -> "Kill transactions with provided ids.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.listCapabilities", "description" -> "List capabilities", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.listConfig", "description" -> "List the currently active config of Neo4j.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.listConnections", "description" -> "List all accepted network connections at this instance that are visible to the user.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.listQueries", "description" -> "List all queries currently executing at this instance that are visible to the user.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.listTransactions", "description" -> "List all transactions currently executing at this instance that are visible to the user.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.procedures", "description" -> "List all procedures in the DBMS.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.queryJmx", "description" -> """Query JMX management data by domain and name. For instance, "*:*"""", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.routing.getRoutingTable", "description" -> "Returns endpoints of this instance.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.security.changePassword", "description" -> "Change the current user's password.", "mode" -> WRITE.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.security.createUser", "description" -> "Create a new user.", "mode" -> WRITE.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.security.deleteUser", "description" -> "Delete the specified user.", "mode" -> WRITE.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.security.listUsers", "description" -> "List all native users.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.showCurrentUser", "description" -> "Show the current user.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.upgrade", "description" -> "Upgrade the system database schema if it is not the current schema.", "mode" -> WRITE.toString, "worksOnSystem" -> true),
    Map("name" -> "dbms.upgradeStatus", "description" -> "Report the current status of the system database sub-graph schema.", "mode" -> READ.toString, "worksOnSystem" -> true),
    Map("name" -> "tx.getMetaData", "description" -> "Provides attached transaction metadata.", "mode" -> DBMS.toString, "worksOnSystem" -> true),
    Map("name" -> "tx.setMetaData", "description" -> "Attaches a map of data to the transaction. The data will be printed when listing queries, and inserted into the query log.", "mode" -> DBMS.toString, "worksOnSystem" -> false)
  )
  private def allDbProceduresVerbose = List(
    Map("name" -> "db.awaitIndex", "description" -> """Wait for an index to come online (for example: CALL db.awaitIndex("MyIndex", 300)).""", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.awaitIndex(indexName :: STRING?, timeOutSeconds = 300 :: INTEGER?) :: VOID", "argumentDescription" -> List(Map("name" -> "indexName", "description" -> "indexName :: STRING?", "type" -> "STRING?"), Map("default" -> "DefaultParameterValue{value=300, type=INTEGER?}", "name" -> "timeOutSeconds", "description" -> "timeOutSeconds = 300 :: INTEGER?", "type" -> "INTEGER?")), "returnDescription" -> List(), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.awaitIndexes", "description" -> "Wait for all indexes to come online (for example: CALL db.awaitIndexes(300)).", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.awaitIndexes(timeOutSeconds = 300 :: INTEGER?) :: VOID", "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=300, type=INTEGER?}", "name" -> "timeOutSeconds", "description" -> "timeOutSeconds = 300 :: INTEGER?", "type" -> "INTEGER?")), "returnDescription" -> List(), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.clearQueryCaches", "description" -> "Clears all query caches.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "db.clearQueryCaches() :: (value :: STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "value", "description" -> "value :: STRING?", "type" -> "STRING?")), "admin" -> true,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.constraints", "description" -> "List all constraints in the database.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.constraints() :: (name :: STRING?, description :: STRING?, details :: STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "name", "description" -> "name :: STRING?", "type" -> "STRING?"), Map("name" -> "description", "description" -> "description :: STRING?", "type" -> "STRING?"), Map("name" -> "details", "description" -> "details :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> true)),
    Map("name" -> "db.createIndex", "description" -> "Create a named schema index with specified index provider and configuration (optional). Yield: name, labels, properties, providerName, status", "mode" -> SCHEMA.toString, "worksOnSystem" -> false, "signature" -> "db.createIndex(indexName :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, providerName :: STRING?, config = {} :: MAP?) :: (name :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, providerName :: STRING?, status :: STRING?)", "argumentDescription" -> List(Map("name" -> "indexName", "description" -> "indexName :: STRING?", "type" -> "STRING?"), Map("name" -> "labels", "description" -> "labels :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "properties", "description" -> "properties :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "providerName", "description" -> "providerName :: STRING?", "type" -> "STRING?"), Map("default" -> "DefaultParameterValue{value={}, type=MAP?}", "name" -> "config", "description" -> "config = {} :: MAP?", "type" -> "MAP?")), "returnDescription" -> List(Map("name" -> "name", "description" -> "name :: STRING?", "type" -> "STRING?"), Map("name" -> "labels", "description" -> "labels :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "properties", "description" -> "properties :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "providerName", "description" -> "providerName :: STRING?", "type" -> "STRING?"), Map("name" -> "status", "description" -> "status :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> true)),
    Map("name" -> "db.createLabel", "description" -> "Create a label", "mode" -> WRITE.toString, "worksOnSystem" -> false, "signature" -> "db.createLabel(newLabel :: STRING?) :: VOID", "argumentDescription" -> List(Map("name" -> "newLabel", "description" -> "newLabel :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.createProperty", "description" -> "Create a Property", "mode" -> WRITE.toString, "worksOnSystem" -> false, "signature" -> "db.createProperty(newProperty :: STRING?) :: VOID", "argumentDescription" -> List(Map("name" -> "newProperty", "description" -> "newProperty :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.createRelationshipType", "description" -> "Create a RelationshipType", "mode" -> WRITE.toString, "worksOnSystem" -> false, "signature" -> "db.createRelationshipType(newRelationshipType :: STRING?) :: VOID", "argumentDescription" -> List(Map("name" -> "newRelationshipType", "description" -> "newRelationshipType :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.createUniquePropertyConstraint", "description" -> "Create a named unique property constraint. Backing index will use specified index provider and configuration (optional). Yield: name, labels, properties, providerName, status", "mode" -> SCHEMA.toString, "worksOnSystem" -> false, "signature" -> "db.createUniquePropertyConstraint(constraintName :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, providerName :: STRING?, config = {} :: MAP?) :: (name :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, providerName :: STRING?, status :: STRING?)", "argumentDescription" -> List(Map("name" -> "constraintName", "description" -> "constraintName :: STRING?", "type" -> "STRING?"), Map("name" -> "labels", "description" -> "labels :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "properties", "description" -> "properties :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "providerName", "description" -> "providerName :: STRING?", "type" -> "STRING?"), Map("default" -> "DefaultParameterValue{value={}, type=MAP?}", "name" -> "config", "description" -> "config = {} :: MAP?", "type" -> "MAP?")), "returnDescription" -> List(Map("name" -> "name", "description" -> "name :: STRING?", "type" -> "STRING?"), Map("name" -> "labels", "description" -> "labels :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "properties", "description" -> "properties :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "providerName", "description" -> "providerName :: STRING?", "type" -> "STRING?"), Map("name" -> "status", "description" -> "status :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> true)),
    Map("name" -> "db.index.fulltext.awaitEventuallyConsistentIndexRefresh", "description" -> "Wait for the updates from recently committed transactions to be applied to any eventually-consistent full-text indexes.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.index.fulltext.awaitEventuallyConsistentIndexRefresh() :: VOID", "argumentDescription" -> List(), "returnDescription" -> List(), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.index.fulltext.createNodeIndex", "description" -> "Create a node full-text index for the given labels and properties. The optional 'config' map parameter can be used to supply settings to the index. Supported settings are 'analyzer', for specifying what analyzer to use when indexing and querying. Use the `db.index.fulltext.listAvailableAnalyzers` procedure to see what options are available. And 'eventually_consistent' which can be set to 'true' to make this index eventually consistent, such that updates from committing transactions are applied in a background thread.", "mode" -> SCHEMA.toString, "worksOnSystem" -> false, "signature" -> "db.index.fulltext.createNodeIndex(indexName :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, config = {} :: MAP?) :: VOID", "argumentDescription" -> List(Map("name" -> "indexName", "description" -> "indexName :: STRING?", "type" -> "STRING?"), Map("name" -> "labels", "description" -> "labels :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "properties", "description" -> "properties :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("default" -> "DefaultParameterValue{value={}, type=MAP?}", "name" -> "config", "description" -> "config = {} :: MAP?", "type" -> "MAP?")), "returnDescription" -> List(), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> true)),
    Map("name" -> "db.index.fulltext.createRelationshipIndex", "description" -> "Create a relationship full-text index for the given relationship types and properties. The optional 'config' map parameter can be used to supply settings to the index. Supported settings are 'analyzer', for specifying what analyzer to use when indexing and querying. Use the `db.index.fulltext.listAvailableAnalyzers` procedure to see what options are available. And 'eventually_consistent' which can be set to 'true' to make this index eventually consistent, such that updates from committing transactions are applied in a background thread.", "mode" -> SCHEMA.toString, "worksOnSystem" -> false, "signature" -> "db.index.fulltext.createRelationshipIndex(indexName :: STRING?, relationshipTypes :: LIST? OF STRING?, properties :: LIST? OF STRING?, config = {} :: MAP?) :: VOID", "argumentDescription" -> List(Map("name" -> "indexName", "description" -> "indexName :: STRING?", "type" -> "STRING?"), Map("name" -> "relationshipTypes", "description" -> "relationshipTypes :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "properties", "description" -> "properties :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("default" -> "DefaultParameterValue{value={}, type=MAP?}", "name" -> "config", "description" -> "config = {} :: MAP?", "type" -> "MAP?")), "returnDescription" -> List(), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> true)),
    Map("name" -> "db.index.fulltext.drop", "description" -> "Drop the specified index.", "mode" -> SCHEMA.toString, "worksOnSystem" -> false, "signature" -> "db.index.fulltext.drop(indexName :: STRING?) :: VOID", "argumentDescription" -> List(Map("name" -> "indexName", "description" -> "indexName :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> true)),
    Map("name" -> "db.index.fulltext.listAvailableAnalyzers", "description" -> "List the available analyzers that the full-text indexes can be configured with.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.index.fulltext.listAvailableAnalyzers() :: (analyzer :: STRING?, description :: STRING?, stopwords :: LIST? OF STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "analyzer", "description" -> "analyzer :: STRING?", "type" -> "STRING?"), Map("name" -> "description", "description" -> "description :: STRING?", "type" -> "STRING?"), Map("name" -> "stopwords", "description" -> "stopwords :: LIST? OF STRING?", "type" -> "LIST? OF STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.index.fulltext.queryNodes", "description" -> "Query the given full-text index. Returns the matching nodes, and their Lucene query score, ordered by score. Valid keys for the options map are: 'skip' to skip the top N results; 'limit' to limit the number of results returned.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.index.fulltext.queryNodes(indexName :: STRING?, queryString :: STRING?, options = {} :: MAP?) :: (node :: NODE?, score :: FLOAT?)", "argumentDescription" -> List(Map("name" -> "indexName", "description" -> "indexName :: STRING?", "type" -> "STRING?"), Map("name" -> "queryString", "description" -> "queryString :: STRING?", "type" -> "STRING?"), Map("default" -> "DefaultParameterValue{value={}, type=MAP?}", "name" -> "options", "description" -> "options = {} :: MAP?", "type" -> "MAP?")), "returnDescription" -> List(Map("name" -> "node", "description" -> "node :: NODE?", "type" -> "NODE?"), Map("name" -> "score", "description" -> "score :: FLOAT?", "type" -> "FLOAT?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.index.fulltext.queryRelationships", "description" -> "Query the given full-text index. Returns the matching relationships, and their Lucene query score, ordered by score. Valid keys for the options map are: 'skip' to skip the top N results; 'limit' to limit the number of results returned.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.index.fulltext.queryRelationships(indexName :: STRING?, queryString :: STRING?, options = {} :: MAP?) :: (relationship :: RELATIONSHIP?, score :: FLOAT?)", "argumentDescription" -> List(Map("name" -> "indexName", "description" -> "indexName :: STRING?", "type" -> "STRING?"), Map("name" -> "queryString", "description" -> "queryString :: STRING?", "type" -> "STRING?"), Map("default" -> "DefaultParameterValue{value={}, type=MAP?}", "name" -> "options", "description" -> "options = {} :: MAP?", "type" -> "MAP?")), "returnDescription" -> List(Map("name" -> "relationship", "description" -> "relationship :: RELATIONSHIP?", "type" -> "RELATIONSHIP?"), Map("name" -> "score", "description" -> "score :: FLOAT?", "type" -> "FLOAT?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.indexDetails", "description" -> "Detailed description of specific index.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.indexDetails(indexName :: STRING?) :: (id :: INTEGER?, name :: STRING?, state :: STRING?, populationPercent :: FLOAT?, uniqueness :: STRING?, type :: STRING?, entityType :: STRING?, labelsOrTypes :: LIST? OF STRING?, properties :: LIST? OF STRING?, provider :: STRING?, indexConfig :: MAP?, failureMessage :: STRING?)", "argumentDescription" -> List(Map("name" -> "indexName", "description" -> "indexName :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(Map("name" -> "id", "description" -> "id :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "name", "description" -> "name :: STRING?", "type" -> "STRING?"), Map("name" -> "state", "description" -> "state :: STRING?", "type" -> "STRING?"), Map("name" -> "populationPercent", "description" -> "populationPercent :: FLOAT?", "type" -> "FLOAT?"), Map("name" -> "uniqueness", "description" -> "uniqueness :: STRING?", "type" -> "STRING?"), Map("name" -> "type", "description" -> "type :: STRING?", "type" -> "STRING?"), Map("name" -> "entityType", "description" -> "entityType :: STRING?", "type" -> "STRING?"), Map("name" -> "labelsOrTypes", "description" -> "labelsOrTypes :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "properties", "description" -> "properties :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "provider", "description" -> "provider :: STRING?", "type" -> "STRING?"), Map("name" -> "indexConfig", "description" -> "indexConfig :: MAP?", "type" -> "MAP?"), Map("name" -> "failureMessage", "description" -> "failureMessage :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> true)),
    Map("name" -> "db.indexes", "description" -> "List all indexes in the database.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.indexes() :: (id :: INTEGER?, name :: STRING?, state :: STRING?, populationPercent :: FLOAT?, uniqueness :: STRING?, type :: STRING?, entityType :: STRING?, labelsOrTypes :: LIST? OF STRING?, properties :: LIST? OF STRING?, provider :: STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "id", "description" -> "id :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "name", "description" -> "name :: STRING?", "type" -> "STRING?"), Map("name" -> "state", "description" -> "state :: STRING?", "type" -> "STRING?"), Map("name" -> "populationPercent", "description" -> "populationPercent :: FLOAT?", "type" -> "FLOAT?"), Map("name" -> "uniqueness", "description" -> "uniqueness :: STRING?", "type" -> "STRING?"), Map("name" -> "type", "description" -> "type :: STRING?", "type" -> "STRING?"), Map("name" -> "entityType", "description" -> "entityType :: STRING?", "type" -> "STRING?"), Map("name" -> "labelsOrTypes", "description" -> "labelsOrTypes :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "properties", "description" -> "properties :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "provider", "description" -> "provider :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> true)),
    Map("name" -> "db.info", "description" -> "Provides information regarding the database.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.info() :: (id :: STRING?, name :: STRING?, creationDate :: STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "id", "description" -> "id :: STRING?", "type" -> "STRING?"), Map("name" -> "name", "description" -> "name :: STRING?", "type" -> "STRING?"), Map("name" -> "creationDate", "description" -> "creationDate :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.labels", "description" -> "List all available labels in the database.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.labels() :: (label :: STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "label", "description" -> "label :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.ping", "description" -> "This procedure can be used by client side tooling to test whether they are correctly connected to a database. The procedure is available in all databases and always returns true. A faulty connection can be detected by not being able to call this procedure.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.ping() :: (success :: BOOLEAN?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "success", "description" -> "success :: BOOLEAN?", "type" -> "BOOLEAN?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.prepareForReplanning", "description" -> "Triggers an index resample and waits for it to complete, and after that clears query caches. After this procedure has finished queries will be planned using the latest database statistics.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.prepareForReplanning(timeOutSeconds = 300 :: INTEGER?) :: VOID", "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=300, type=INTEGER?}", "name" -> "timeOutSeconds", "description" -> "timeOutSeconds = 300 :: INTEGER?", "type" -> "INTEGER?")), "returnDescription" -> List(), "admin" -> true,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.propertyKeys", "description" -> "List all property keys in the database.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.propertyKeys() :: (propertyKey :: STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "propertyKey", "description" -> "propertyKey :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.relationshipTypes", "description" -> "List all available relationship types in the database.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.relationshipTypes() :: (relationshipType :: STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "relationshipType", "description" -> "relationshipType :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.resampleIndex", "description" -> """Schedule resampling of an index (for example: CALL db.resampleIndex("MyIndex")).""", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.resampleIndex(indexName :: STRING?) :: VOID", "argumentDescription" -> List(Map("name" -> "indexName", "description" -> "indexName :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.resampleOutdatedIndexes", "description" -> "Schedule resampling of all outdated indexes.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.resampleOutdatedIndexes() :: VOID", "argumentDescription" -> List(), "returnDescription" -> List(), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.schema.nodeTypeProperties", "description" -> "Show the derived property schema of the nodes in tabular form.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.schema.nodeTypeProperties() :: (nodeType :: STRING?, nodeLabels :: LIST? OF STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "nodeType", "description" -> "nodeType :: STRING?", "type" -> "STRING?"), Map("name" -> "nodeLabels", "description" -> "nodeLabels :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "propertyName", "description" -> "propertyName :: STRING?", "type" -> "STRING?"), Map("name" -> "propertyTypes", "description" -> "propertyTypes :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "mandatory", "description" -> "mandatory :: BOOLEAN?", "type" -> "BOOLEAN?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.schema.relTypeProperties", "description" -> "Show the derived property schema of the relationships in tabular form.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.schema.relTypeProperties() :: (relType :: STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "relType", "description" -> "relType :: STRING?", "type" -> "STRING?"), Map("name" -> "propertyName", "description" -> "propertyName :: STRING?", "type" -> "STRING?"), Map("name" -> "propertyTypes", "description" -> "propertyTypes :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "mandatory", "description" -> "mandatory :: BOOLEAN?", "type" -> "BOOLEAN?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.schema.visualization", "description" -> "Visualize the schema of the data.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.schema.visualization() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "nodes", "description" -> "nodes :: LIST? OF NODE?", "type" -> "LIST? OF NODE?"), Map("name" -> "relationships", "description" -> "relationships :: LIST? OF RELATIONSHIP?", "type" -> "LIST? OF RELATIONSHIP?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.schemaStatements", "description" -> "List all statements for creating and dropping existing indexes and constraints. Note that only index types introduced before Neo4j 4.3 are included.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.schemaStatements() :: (name :: STRING?, type :: STRING?, createStatement :: STRING?, dropStatement :: STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "name", "description" -> "name :: STRING?", "type" -> "STRING?"), Map("name" -> "type", "description" -> "type :: STRING?", "type" -> "STRING?"), Map("name" -> "createStatement", "description" -> "createStatement :: STRING?", "type" -> "STRING?"), Map("name" -> "dropStatement", "description" -> "dropStatement :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> true)),
    Map("name" -> "db.stats.clear", "description" -> "Clear collected data of a given data section. Valid sections are 'QUERIES'", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.stats.clear(section :: STRING?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?)", "argumentDescription" -> List(Map("name" -> "section", "description" -> "section :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(Map("name" -> "section", "description" -> "section :: STRING?", "type" -> "STRING?"), Map("name" -> "success", "description" -> "success :: BOOLEAN?", "type" -> "BOOLEAN?"), Map("name" -> "message", "description" -> "message :: STRING?", "type" -> "STRING?")), "admin" -> true,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.stats.collect", "description" -> "Start data collection of a given data section. Valid sections are 'QUERIES'", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.stats.collect(section :: STRING?, config = {} :: MAP?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?)", "argumentDescription" -> List(Map("name" -> "section", "description" -> "section :: STRING?", "type" -> "STRING?"), Map("default" -> "DefaultParameterValue{value={}, type=MAP?}", "name" -> "config", "description" -> "config = {} :: MAP?", "type" -> "MAP?")), "returnDescription" -> List(Map("name" -> "section", "description" -> "section :: STRING?", "type" -> "STRING?"), Map("name" -> "success", "description" -> "success :: BOOLEAN?", "type" -> "BOOLEAN?"), Map("name" -> "message", "description" -> "message :: STRING?", "type" -> "STRING?")), "admin" -> true,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.stats.retrieve", "description" -> "Retrieve statistical data about the current database. Valid sections are 'GRAPH COUNTS', 'TOKENS', 'QUERIES', 'META'", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.stats.retrieve(section :: STRING?, config = {} :: MAP?) :: (section :: STRING?, data :: MAP?)", "argumentDescription" -> List(Map("name" -> "section", "description" -> "section :: STRING?", "type" -> "STRING?"), Map("default" -> "DefaultParameterValue{value={}, type=MAP?}", "name" -> "config", "description" -> "config = {} :: MAP?", "type" -> "MAP?")), "returnDescription" -> List(Map("name" -> "section", "description" -> "section :: STRING?", "type" -> "STRING?"), Map("name" -> "data", "description" -> "data :: MAP?", "type" -> "MAP?")), "admin" -> true,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.stats.retrieveAllAnonymized", "description" -> "Retrieve all available statistical data about the current database, in an anonymized form.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.stats.retrieveAllAnonymized(graphToken :: STRING?, config = {} :: MAP?) :: (section :: STRING?, data :: MAP?)", "argumentDescription" -> List(Map("name" -> "graphToken", "description" -> "graphToken :: STRING?", "type" -> "STRING?"), Map("default" -> "DefaultParameterValue{value={}, type=MAP?}", "name" -> "config", "description" -> "config = {} :: MAP?", "type" -> "MAP?")), "returnDescription" -> List(Map("name" -> "section", "description" -> "section :: STRING?", "type" -> "STRING?"), Map("name" -> "data", "description" -> "data :: MAP?", "type" -> "MAP?")), "admin" -> true,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.stats.status", "description" -> "Retrieve the status of all available collector daemons, for this database.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.stats.status() :: (section :: STRING?, status :: STRING?, data :: MAP?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "section", "description" -> "section :: STRING?", "type" -> "STRING?"), Map("name" -> "status", "description" -> "status :: STRING?", "type" -> "STRING?"), Map("name" -> "data", "description" -> "data :: MAP?", "type" -> "MAP?")), "admin" -> true,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "db.stats.stop", "description" -> "Stop data collection of a given data section. Valid sections are 'QUERIES'", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "db.stats.stop(section :: STRING?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?)", "argumentDescription" -> List(Map("name" -> "section", "description" -> "section :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(Map("name" -> "section", "description" -> "section :: STRING?", "type" -> "STRING?"), Map("name" -> "success", "description" -> "success :: BOOLEAN?", "type" -> "BOOLEAN?"), Map("name" -> "message", "description" -> "message :: STRING?", "type" -> "STRING?")), "admin" -> true,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
  )
  private def allDbmsProceduresVerbose = List(
    Map("name" -> "dbms.cluster.routing.getRoutingTable", "description" -> "Returns endpoints of this instance.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.cluster.routing.getRoutingTable(context :: MAP?, database = null :: STRING?) :: (ttl :: INTEGER?, servers :: LIST? OF MAP?)", "argumentDescription" -> List(Map("name" -> "context", "description" -> "context :: MAP?", "type" -> "MAP?"), Map("default" -> "DefaultParameterValue{value=null, type=STRING?}", "name" -> "database", "description" -> "database = null :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(Map("name" -> "ttl", "description" -> "ttl :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "servers", "description" -> "servers :: LIST? OF MAP?", "type" -> "LIST? OF MAP?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.components", "description" -> "List DBMS components and their versions.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.components() :: (name :: STRING?, versions :: LIST? OF STRING?, edition :: STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "name", "description" -> "name :: STRING?", "type" -> "STRING?"), Map("name" -> "versions", "description" -> "versions :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "edition", "description" -> "edition :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.database.state", "description" -> "The actual status of the database with the provided name on this neo4j instance.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.database.state(databaseName :: STRING?) :: (role :: STRING?, address :: STRING?, status :: STRING?, error :: STRING?)", "argumentDescription" -> List(Map("name" -> "databaseName", "description" -> "databaseName :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(Map("name" -> "role", "description" -> "role :: STRING?", "type" -> "STRING?"), Map("name" -> "address", "description" -> "address :: STRING?", "type" -> "STRING?"), Map("name" -> "status", "description" -> "status :: STRING?", "type" -> "STRING?"), Map("name" -> "error", "description" -> "error :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.functions", "description" -> "List all functions in the DBMS.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.functions() :: (name :: STRING?, signature :: STRING?, category :: STRING?, description :: STRING?, aggregating :: BOOLEAN?, defaultBuiltInRoles :: LIST? OF STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "name", "description" -> "name :: STRING?", "type" -> "STRING?"), Map("name" -> "signature", "description" -> "signature :: STRING?", "type" -> "STRING?"), Map("name" -> "category", "description" -> "category :: STRING?", "type" -> "STRING?"), Map("name" -> "description", "description" -> "description :: STRING?", "type" -> "STRING?"), Map("name" -> "aggregating", "description" -> "aggregating :: BOOLEAN?", "type" -> "BOOLEAN?"), Map("name" -> "defaultBuiltInRoles", "description" -> "defaultBuiltInRoles :: LIST? OF STRING?", "type" -> "LIST? OF STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> true)),
    Map("name" -> "dbms.info", "description" -> "Provides information regarding the DBMS.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.info() :: (id :: STRING?, name :: STRING?, creationDate :: STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "id", "description" -> "id :: STRING?", "type" -> "STRING?"), Map("name" -> "name", "description" -> "name :: STRING?", "type" -> "STRING?"), Map("name" -> "creationDate", "description" -> "creationDate :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.killConnection", "description" -> "Kill network connection with the given connection id.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.killConnection(id :: STRING?) :: (connectionId :: STRING?, username :: STRING?, message :: STRING?)", "argumentDescription" -> List(Map("name" -> "id", "description" -> "id :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(Map("name" -> "connectionId", "description" -> "connectionId :: STRING?", "type" -> "STRING?"), Map("name" -> "username", "description" -> "username :: STRING?", "type" -> "STRING?"), Map("name" -> "message", "description" -> "message :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.killConnections", "description" -> "Kill all network connections with the given connection ids.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.killConnections(ids :: LIST? OF STRING?) :: (connectionId :: STRING?, username :: STRING?, message :: STRING?)", "argumentDescription" -> List(Map("name" -> "ids", "description" -> "ids :: LIST? OF STRING?", "type" -> "LIST? OF STRING?")), "returnDescription" -> List(Map("name" -> "connectionId", "description" -> "connectionId :: STRING?", "type" -> "STRING?"), Map("name" -> "username", "description" -> "username :: STRING?", "type" -> "STRING?"), Map("name" -> "message", "description" -> "message :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.killQueries", "description" -> "Kill all transactions executing a query with any of the given query ids.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.killQueries(ids :: LIST? OF STRING?) :: (queryId :: STRING?, username :: STRING?, message :: STRING?)", "argumentDescription" -> List(Map("name" -> "ids", "description" -> "ids :: LIST? OF STRING?", "type" -> "LIST? OF STRING?")), "returnDescription" -> List(Map("name" -> "queryId", "description" -> "queryId :: STRING?", "type" -> "STRING?"), Map("name" -> "username", "description" -> "username :: STRING?", "type" -> "STRING?"), Map("name" -> "message", "description" -> "message :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.killQuery", "description" -> "Kill all transactions executing the query with the given query id.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.killQuery(id :: STRING?) :: (queryId :: STRING?, username :: STRING?, message :: STRING?)", "argumentDescription" -> List(Map("name" -> "id", "description" -> "id :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(Map("name" -> "queryId", "description" -> "queryId :: STRING?", "type" -> "STRING?"), Map("name" -> "username", "description" -> "username :: STRING?", "type" -> "STRING?"), Map("name" -> "message", "description" -> "message :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.killTransaction", "description" -> "Kill transaction with provided id.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.killTransaction(id :: STRING?) :: (transactionId :: STRING?, username :: STRING?, message :: STRING?)", "argumentDescription" -> List(Map("name" -> "id", "description" -> "id :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(Map("name" -> "transactionId", "description" -> "transactionId :: STRING?", "type" -> "STRING?"), Map("name" -> "username", "description" -> "username :: STRING?", "type" -> "STRING?"), Map("name" -> "message", "description" -> "message :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.killTransactions", "description" -> "Kill transactions with provided ids.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.killTransactions(ids :: LIST? OF STRING?) :: (transactionId :: STRING?, username :: STRING?, message :: STRING?)", "argumentDescription" -> List(Map("name" -> "ids", "description" -> "ids :: LIST? OF STRING?", "type" -> "LIST? OF STRING?")), "returnDescription" -> List(Map("name" -> "transactionId", "description" -> "transactionId :: STRING?", "type" -> "STRING?"), Map("name" -> "username", "description" -> "username :: STRING?", "type" -> "STRING?"), Map("name" -> "message", "description" -> "message :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.listCapabilities", "description" -> "List capabilities", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.listCapabilities() :: (name :: STRING?, description :: STRING?, value :: ANY?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "name", "description" -> "name :: STRING?", "type" -> "STRING?"), Map("name" -> "description", "description" -> "description :: STRING?", "type" -> "STRING?"), Map("name" -> "value", "description" -> "value :: ANY?", "type" -> "ANY?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.listConfig", "description" -> "List the currently active config of Neo4j.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.listConfig(searchString =  :: STRING?) :: (name :: STRING?, description :: STRING?, value :: STRING?, dynamic :: BOOLEAN?)", "argumentDescription" -> List(Map("default" -> "DefaultParameterValue{value=, type=STRING?}", "name" -> "searchString", "description" -> "searchString =  :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(Map("name" -> "name", "description" -> "name :: STRING?", "type" -> "STRING?"), Map("name" -> "description", "description" -> "description :: STRING?", "type" -> "STRING?"), Map("name" -> "value", "description" -> "value :: STRING?", "type" -> "STRING?"), Map("name" -> "dynamic", "description" -> "dynamic :: BOOLEAN?", "type" -> "BOOLEAN?")), "admin" -> true,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.listConnections", "description" -> "List all accepted network connections at this instance that are visible to the user.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.listConnections() :: (connectionId :: STRING?, connectTime :: STRING?, connector :: STRING?, username :: STRING?, userAgent :: STRING?, serverAddress :: STRING?, clientAddress :: STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "connectionId", "description" -> "connectionId :: STRING?", "type" -> "STRING?"), Map("name" -> "connectTime", "description" -> "connectTime :: STRING?", "type" -> "STRING?"), Map("name" -> "connector", "description" -> "connector :: STRING?", "type" -> "STRING?"), Map("name" -> "username", "description" -> "username :: STRING?", "type" -> "STRING?"), Map("name" -> "userAgent", "description" -> "userAgent :: STRING?", "type" -> "STRING?"), Map("name" -> "serverAddress", "description" -> "serverAddress :: STRING?", "type" -> "STRING?"), Map("name" -> "clientAddress", "description" -> "clientAddress :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.listQueries", "description" -> "List all queries currently executing at this instance that are visible to the user.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.listQueries() :: (queryId :: STRING?, username :: STRING?, metaData :: MAP?, query :: STRING?, parameters :: MAP?, planner :: STRING?, runtime :: STRING?, indexes :: LIST? OF MAP?, startTime :: STRING?, protocol :: STRING?, clientAddress :: STRING?, requestUri :: STRING?, status :: STRING?, resourceInformation :: MAP?, activeLockCount :: INTEGER?, elapsedTimeMillis :: INTEGER?, cpuTimeMillis :: INTEGER?, waitTimeMillis :: INTEGER?, idleTimeMillis :: INTEGER?, allocatedBytes :: INTEGER?, pageHits :: INTEGER?, pageFaults :: INTEGER?, connectionId :: STRING?, database :: STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "queryId", "description" -> "queryId :: STRING?", "type" -> "STRING?"), Map("name" -> "username", "description" -> "username :: STRING?", "type" -> "STRING?"), Map("name" -> "metaData", "description" -> "metaData :: MAP?", "type" -> "MAP?"), Map("name" -> "query", "description" -> "query :: STRING?", "type" -> "STRING?"), Map("name" -> "parameters", "description" -> "parameters :: MAP?", "type" -> "MAP?"), Map("name" -> "planner", "description" -> "planner :: STRING?", "type" -> "STRING?"), Map("name" -> "runtime", "description" -> "runtime :: STRING?", "type" -> "STRING?"), Map("name" -> "indexes", "description" -> "indexes :: LIST? OF MAP?", "type" -> "LIST? OF MAP?"), Map("name" -> "startTime", "description" -> "startTime :: STRING?", "type" -> "STRING?"), Map("name" -> "protocol", "description" -> "protocol :: STRING?", "type" -> "STRING?"), Map("name" -> "clientAddress", "description" -> "clientAddress :: STRING?", "type" -> "STRING?"), Map("name" -> "requestUri", "description" -> "requestUri :: STRING?", "type" -> "STRING?"), Map("name" -> "status", "description" -> "status :: STRING?", "type" -> "STRING?"), Map("name" -> "resourceInformation", "description" -> "resourceInformation :: MAP?", "type" -> "MAP?"), Map("name" -> "activeLockCount", "description" -> "activeLockCount :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "elapsedTimeMillis", "description" -> "elapsedTimeMillis :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "cpuTimeMillis", "description" -> "cpuTimeMillis :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "waitTimeMillis", "description" -> "waitTimeMillis :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "idleTimeMillis", "description" -> "idleTimeMillis :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "allocatedBytes", "description" -> "allocatedBytes :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "pageHits", "description" -> "pageHits :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "pageFaults", "description" -> "pageFaults :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "connectionId", "description" -> "connectionId :: STRING?", "type" -> "STRING?"), Map("name" -> "database", "description" -> "database :: STRING?", "type" -> "STRING?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.listTransactions", "description" -> "List all transactions currently executing at this instance that are visible to the user.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.listTransactions() :: (transactionId :: STRING?, username :: STRING?, metaData :: MAP?, startTime :: STRING?, protocol :: STRING?, clientAddress :: STRING?, requestUri :: STRING?, currentQueryId :: STRING?, currentQuery :: STRING?, activeLockCount :: INTEGER?, status :: STRING?, resourceInformation :: MAP?, elapsedTimeMillis :: INTEGER?, cpuTimeMillis :: INTEGER?, waitTimeMillis :: INTEGER?, idleTimeMillis :: INTEGER?, allocatedBytes :: INTEGER?, allocatedDirectBytes :: INTEGER?, pageHits :: INTEGER?, pageFaults :: INTEGER?, connectionId :: STRING?, initializationStackTrace :: STRING?, database :: STRING?, estimatedUsedHeapMemory :: INTEGER?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "transactionId", "description" -> "transactionId :: STRING?", "type" -> "STRING?"), Map("name" -> "username", "description" -> "username :: STRING?", "type" -> "STRING?"), Map("name" -> "metaData", "description" -> "metaData :: MAP?", "type" -> "MAP?"), Map("name" -> "startTime", "description" -> "startTime :: STRING?", "type" -> "STRING?"), Map("name" -> "protocol", "description" -> "protocol :: STRING?", "type" -> "STRING?"), Map("name" -> "clientAddress", "description" -> "clientAddress :: STRING?", "type" -> "STRING?"), Map("name" -> "requestUri", "description" -> "requestUri :: STRING?", "type" -> "STRING?"), Map("name" -> "currentQueryId", "description" -> "currentQueryId :: STRING?", "type" -> "STRING?"), Map("name" -> "currentQuery", "description" -> "currentQuery :: STRING?", "type" -> "STRING?"), Map("name" -> "activeLockCount", "description" -> "activeLockCount :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "status", "description" -> "status :: STRING?", "type" -> "STRING?"), Map("name" -> "resourceInformation", "description" -> "resourceInformation :: MAP?", "type" -> "MAP?"), Map("name" -> "elapsedTimeMillis", "description" -> "elapsedTimeMillis :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "cpuTimeMillis", "description" -> "cpuTimeMillis :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "waitTimeMillis", "description" -> "waitTimeMillis :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "idleTimeMillis", "description" -> "idleTimeMillis :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "allocatedBytes", "description" -> "allocatedBytes :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "allocatedDirectBytes", "description" -> "allocatedDirectBytes :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "pageHits", "description" -> "pageHits :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "pageFaults", "description" -> "pageFaults :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "connectionId", "description" -> "connectionId :: STRING?", "type" -> "STRING?"), Map("name" -> "initializationStackTrace", "description" -> "initializationStackTrace :: STRING?", "type" -> "STRING?"), Map("name" -> "database", "description" -> "database :: STRING?", "type" -> "STRING?"), Map("name" -> "estimatedUsedHeapMemory", "description" -> "estimatedUsedHeapMemory :: INTEGER?", "type" -> "INTEGER?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.procedures", "description" -> "List all procedures in the DBMS.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.procedures() :: (name :: STRING?, signature :: STRING?, description :: STRING?, mode :: STRING?, defaultBuiltInRoles :: LIST? OF STRING?, worksOnSystem :: BOOLEAN?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "name", "description" -> "name :: STRING?", "type" -> "STRING?"), Map("name" -> "signature", "description" -> "signature :: STRING?", "type" -> "STRING?"), Map("name" -> "description", "description" -> "description :: STRING?", "type" -> "STRING?"), Map("name" -> "mode", "description" -> "mode :: STRING?", "type" -> "STRING?"), Map("name" -> "defaultBuiltInRoles", "description" -> "defaultBuiltInRoles :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "worksOnSystem", "description" -> "worksOnSystem :: BOOLEAN?", "type" -> "BOOLEAN?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> true)),
    Map("name" -> "dbms.queryJmx", "description" -> """Query JMX management data by domain and name. For instance, "*:*"""", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.queryJmx(query :: STRING?) :: (name :: STRING?, description :: STRING?, attributes :: MAP?)", "argumentDescription" -> List(Map("name" -> "query", "description" -> "query :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(Map("name" -> "name", "description" -> "name :: STRING?", "type" -> "STRING?"), Map("name" -> "description", "description" -> "description :: STRING?", "type" -> "STRING?"), Map("name" -> "attributes", "description" -> "attributes :: MAP?", "type" -> "MAP?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.routing.getRoutingTable", "description" -> "Returns endpoints of this instance.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.routing.getRoutingTable(context :: MAP?, database = null :: STRING?) :: (ttl :: INTEGER?, servers :: LIST? OF MAP?)", "argumentDescription" -> List(Map("name" -> "context", "description" -> "context :: MAP?", "type" -> "MAP?"), Map("default" -> "DefaultParameterValue{value=null, type=STRING?}", "name" -> "database", "description" -> "database = null :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(Map("name" -> "ttl", "description" -> "ttl :: INTEGER?", "type" -> "INTEGER?"), Map("name" -> "servers", "description" -> "servers :: LIST? OF MAP?", "type" -> "LIST? OF MAP?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.security.changePassword", "description" -> "Change the current user's password.", "mode" -> WRITE.toString, "worksOnSystem" -> true, "signature" -> "dbms.security.changePassword(password :: STRING?) :: VOID", "argumentDescription" -> List(Map("name" -> "password", "description" -> "password :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(), "admin" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> true)),
    Map("name" -> "dbms.security.createUser", "description" -> "Create a new user.", "mode" -> WRITE.toString, "worksOnSystem" -> true, "signature" -> "dbms.security.createUser(username :: STRING?, password :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID", "argumentDescription" -> List(Map("name" -> "username", "description" -> "username :: STRING?", "type" -> "STRING?"), Map("name" -> "password", "description" -> "password :: STRING?", "type" -> "STRING?"), Map("default" -> "DefaultParameterValue{value=true, type=BOOLEAN?}", "name" -> "requirePasswordChange", "description" -> "requirePasswordChange = true :: BOOLEAN?", "type" -> "BOOLEAN?")), "returnDescription" -> List(), "admin" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> true)),
    Map("name" -> "dbms.security.deleteUser", "description" -> "Delete the specified user.", "mode" -> WRITE.toString, "worksOnSystem" -> true, "signature" -> "dbms.security.deleteUser(username :: STRING?) :: VOID", "argumentDescription" -> List(Map("name" -> "username", "description" -> "username :: STRING?", "type" -> "STRING?")), "returnDescription" -> List(), "admin" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> true)),
    Map("name" -> "dbms.security.listUsers", "description" -> "List all native users.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "dbms.security.listUsers() :: (username :: STRING?, roles :: LIST? OF STRING?, flags :: LIST? OF STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "username", "description" -> "username :: STRING?", "type" -> "STRING?"), Map("name" -> "roles", "description" -> "roles :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "flags", "description" -> "flags :: LIST? OF STRING?", "type" -> "LIST? OF STRING?")), "admin" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> true)),
    Map("name" -> "dbms.showCurrentUser", "description" -> "Show the current user.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "dbms.showCurrentUser() :: (username :: STRING?, roles :: LIST? OF STRING?, flags :: LIST? OF STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "username", "description" -> "username :: STRING?", "type" -> "STRING?"), Map("name" -> "roles", "description" -> "roles :: LIST? OF STRING?", "type" -> "LIST? OF STRING?"), Map("name" -> "flags", "description" -> "flags :: LIST? OF STRING?", "type" -> "LIST? OF STRING?")), "admin" -> false, "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.upgrade", "description" -> "Upgrade the system database schema if it is not the current schema.", "mode" -> WRITE.toString, "worksOnSystem" -> true, "signature" -> "dbms.upgrade() :: (status :: STRING?, upgradeResult :: STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "status", "description" -> "status :: STRING?", "type" -> "STRING?"), Map("name" -> "upgradeResult", "description" -> "upgradeResult :: STRING?", "type" -> "STRING?")), "admin" -> true,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "dbms.upgradeStatus", "description" -> "Report the current status of the system database sub-graph schema.", "mode" -> READ.toString, "worksOnSystem" -> true, "signature" -> "dbms.upgradeStatus() :: (status :: STRING?, description :: STRING?, resolution :: STRING?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "status", "description" -> "status :: STRING?", "type" -> "STRING?"), Map("name" -> "description", "description" -> "description :: STRING?", "type" -> "STRING?"), Map("name" -> "resolution", "description" -> "resolution :: STRING?", "type" -> "STRING?")), "admin" -> true,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "tx.getMetaData", "description" -> "Provides attached transaction metadata.", "mode" -> DBMS.toString, "worksOnSystem" -> true, "signature" -> "tx.getMetaData() :: (metadata :: MAP?)", "argumentDescription" -> List(), "returnDescription" -> List(Map("name" -> "metadata", "description" -> "metadata :: MAP?", "type" -> "MAP?")), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false)),
    Map("name" -> "tx.setMetaData", "description" -> "Attaches a map of data to the transaction. The data will be printed when listing queries, and inserted into the query log.", "mode" -> DBMS.toString, "worksOnSystem" -> false, "signature" -> "tx.setMetaData(data :: MAP?) :: VOID", "argumentDescription" -> List(Map("name" -> "data", "description" -> "data :: MAP?", "type" -> "MAP?")), "returnDescription" -> List(), "admin" -> false,  "rolesExecution" -> null, "rolesBoostedExecution" -> null, "option" -> Map("deprecated" -> false))
  )
  private def allProceduresVerbose = allDbProceduresVerbose ++ allDbmsProceduresVerbose

  test("should show procedures") {
    // GIVEN
    selectDatabase(DEFAULT_DATABASE_NAME)

    // WHEN
    val result = execute("SHOW PROCEDURES")

    // THEN
    result.toList should be(allProceduresBrief)
  }

  test("should show procedures with yield") {
    // GIVEN
    selectDatabase(DEFAULT_DATABASE_NAME)

    // WHEN
    val result = execute("SHOW PROCEDURES YIELD *")

    // THEN
    result.toList should be(allProceduresVerbose)
  }

  test("should show procedures executable by current user") {
    // GIVEN
    createUser()

    // WHEN
    val result = executeAs(username, password, "SHOW PROCEDURES EXECUTABLE")

    // THEN
    result.toList should be(allProceduresBrief)
  }

  test("should show procedures executable by current user with yield") {
    // GIVEN
    createUser()

    // WHEN
    val result = executeAs(username, password, "SHOW PROCEDURES EXECUTABLE YIELD name, description, signature")

    // THEN
    result.toList should be(allProceduresVerbose.map(m => m.filterKeys(k => Seq("name", "description", "signature").contains(k))))
  }

  test("should show procedures executable by specified user") {
    // GIVEN
    createUser()

    // WHEN
    val result = execute(s"SHOW PROCEDURES EXECUTABLE BY $username")

    // THEN
    result.toList should be(allProceduresBrief)
  }

  test("should show procedures executable by specified user with yield") {
    // GIVEN
    createUser()

    // WHEN
    val result = execute(s"SHOW PROCEDURES EXECUTABLE BY $username YIELD *")

    // THEN
    result.toList should be(allProceduresVerbose)
  }

  test("should show procedures on system") {
    // GIVEN
    selectDatabase(SYSTEM_DATABASE_NAME)

    // WHEN
    val result = execute("SHOW PROCEDURES")

    // THEN
    result.toList should be(allProceduresBrief)
  }

  // Help methods

  private def createUser(): Unit = {
    selectDatabase(SYSTEM_DATABASE_NAME)
    execute(s"CREATE USER $username SET PASSWORD '$password' CHANGE NOT REQUIRED")
    selectDatabase(DEFAULT_DATABASE_NAME)
  }

  def executeAs(username: String, password: String, queryText: String, params: Map[String, Any] = Map.empty): RewindableExecutionResult = {
    val authManager = graph.getDependencyResolver.resolveDependency(classOf[AuthManager])
    val login = authManager.login(SecurityTestUtils.authToken(username, password), ClientConnectionInfo.EMBEDDED_CONNECTION)
    val tx = graph.beginTransaction(Type.EXPLICIT, login)
    try {
      val result = execute(queryText, params, tx)
      tx.commit()
      result
    } finally {
      tx.close()
    }
  }
}

class TestShowFunction {
  @UserFunction( "test.function" )
  def function(): String = "OK"

  @UserFunction( "test.functionWithInput" )
  def functionWithInput(@Name("input") input: String): ListValue = {
    val inputVal = Values.stringValue(input)
    val values: List[AnyValue] = List(inputVal, inputVal, inputVal)
    VirtualValues.fromList(values.asJava)
  }

  @UserAggregationFunction( "test.return.latest" )
  @Description( "Return the latest number, continuously updating the value." )
  def myAggFunc: ReturnLatest = new ReturnLatest
}

object TestShowFunction {
  def apply(): TestShowFunction = new TestShowFunction()
}

class ReturnLatest {
  var latest: Long = 0

  @UserAggregationUpdate
  def update(@Name("value") value: Long): Unit = latest = value

  @UserAggregationResult
  def result: Long = latest
}
